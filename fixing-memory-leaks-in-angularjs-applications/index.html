<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Fixing Memory Leaks in AngularJS and other JavaScript Applications &#183; Dave Kerr</title><meta name=description content="Dealing with memory leaks in JavaScript applications can be a complex process. In this article I'm going to show you how to identify whether you have memory leaks, analyse them and ultimately resolve them.
I'm using an AngularJS application to demonstrate the concepts and approaches, but much of this material applies to any JavaScript application.
 Understanding Memory Leaks  What is a Memory Leak? Why is a Memory Leak Bad?"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.61.0"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Fixing Memory Leaks in AngularJS and other JavaScript Applications"><meta property="og:description" content="Dealing with memory leaks in JavaScript applications can be a complex process. In this article I'm going to show you how to identify whether you have memory leaks, analyse them and ultimately resolve them.
I'm using an AngularJS application to demonstrate the concepts and approaches, but much of this material applies to any JavaScript application.
 Understanding Memory Leaks  What is a Memory Leak? Why is a Memory Leak Bad?"><meta property="og:type" content="article"><meta property="og:url" content="https://dwmkerr.github.io/dwmkerr.com/fixing-memory-leaks-in-angularjs-applications/"><link rel=stylesheet href=https://dwmkerr.github.io/dwmkerr.com/dist/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous></head><body><script type=application/javascript>var dnt=(navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack);var doNotTrack=(dnt=="1"||dnt=="yes");if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-41728580-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a title=dwmkerr.com href=https://dwmkerr.github.io/dwmkerr.com/>dwmkerr.com</a></h1><a class=button-square href=https://dwmkerr.github.io/dwmkerr.com/index.xml><i class="fa fa-rss"></i></a><a class="button-square button-social hint--top" data-hint=Twitter title=Twitter href=https://twitter.com/dwmkerr rel=me><i class="fa fa-twitter"></i></a><a class="button-square button-social hint--top" data-hint=Github title=Github href=https://github.com/dwmkerr rel=me><i class="fa fa-github-alt"></i></a><a class="button-square button-social hint--top" data-hint="Stack Overflow" title="Stack Overflow" href=https://stackoverflow.com/users/1189164/dave-kerr rel=me><i class="fa fa-stack-overflow"></i></a><a class="button-square button-social hint--top" data-hint=LinkedIn title=LinkedIn href=https://www.linkedin.com/in/dwmkerr/ rel=me><i class="fa fa-linkedin"></i></a></div><ul class=site-nav><li class=site-nav-item><a title=Blog href=/dwmkerr.com/>Blog</a></li><li class=site-nav-item><a title=Speaking href=/dwmkerr.com/page/speaking/>Speaking</a></li><li class=site-nav-item><a title=About href=/dwmkerr.com/page/about/>About</a></li></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Fixing Memory Leaks in AngularJS and other JavaScript Applications</h1><p class="post-date post-line"><span>Published <time datetime=2015-03-03 itemprop=datePublished>Tue, Mar 3, 2015</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=https://github.com/dwmkerr itemprop=url rel=author>Dave Kerr</a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><img class=post-featured-image src=/images/2015/03/TimelineLeakySawtooth-1.png><p>Dealing with memory leaks in JavaScript applications can be a complex process. In this article I'm going to show you how to identify whether you have memory leaks, analyse them and ultimately resolve them.</p><p>I'm using an AngularJS application to demonstrate the concepts and approaches, but much of this material applies to any JavaScript application.</p><ol><li><a href=#understandingmemoryleaks>Understanding Memory Leaks</a><ul><li>What is a Memory Leak?</li><li>Why is a Memory Leak Bad?</li></ul></li><li><a href=#identifyingmemoryleaks>Identifying Memory Leaks</a><ul><li>Method 1: The Wrong Way</li><li>Method 2: The Timeline</li><li>Method 3: Recording Heap Allocations</li><li>Method 4: Heap Snapshots</li></ul></li><li><a href=#analysingmemoryleaks>Analysing Memory Leaks</a><ul><li>Analysing the leak in Scenario 2</li><li>More on Graphs</li></ul></li><li><a href=#fixingmemoryleaks>Fixing Memory Leaks</a><ul><li>Three golden rules</li><li>Anti-patterns to avoid</li></ul></li><li><a href=#thefuture>The Future</a><ul><li>Weak Maps</li><li>AngularJS 2</li><li>Even Better Browsers</li></ul></li><li><a href=#appendices>Appendices</a><ul><li>Thanks</li><li>Mysteries</li><li>Futher Reading</li></ul></li></ol><h2 id=understanding-memory-leaks>Understanding Memory Leaks</h2><p>If you've dealt with memory leaks before, or the patterns of memory usage we sometimes call memory leaks in memory managed applications, then you can probably skip to <a href=#identifyingmemoryleaks>Identifying Memory Leaks</a>.</p><p>If not let's start with some theory.</p><h3 id=what-is-a-memory-leak>What is a Memory Leak?</h3><p>A memory leak, at least in the world of unmanaged applications, is what occurs when you allocate memory and forget to free it. In pseudo-code<sup><a href=#fn1 id=ref1>1</a></sup>:</p><pre><code>void leaky()
{
    void* memory;
    memory = malloc(1000);
    /* malloc just gave us some memory, use it! */
}
</code></pre><p><code>memory</code> will hold the address of the memory we've allocate. We use the memory, then the function ends. <code>memory</code> goes out of scope and whatever address it held is lost - but we didn't free the memory! Not only that, we've lost the address of it so can't ever free it in the future - it's <em>leaked</em>.</p><p>This memory is lost to the application - we can't release it. Only terminating the process will release it back to the operating system.</p><blockquote><p>When we allocate memory and don't release it when we are done, we have &lsquo;leaked&rsquo; that memory.</p></blockquote><p>So how do we get memory leaks in JavaScript applications? We don't allocate memory directly, the engine does it for us, and it cleans it up afterwards as well<sup><a href=#fn2 id=ref2>2</a></sup>.</p><p>If we hold on to objects longer than we need to, that will give us similar results. Let's look at some code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ChessManager</span>() {
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>moves</span> <span style=color:#f92672>=</span> [];
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>makeMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>move</span>) {
  	<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>moves</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>move</span>);
  };
  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>newGame</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>moves</span>.<span style=color:#a6e22e>clear</span>();
  };
}
</code></pre></div><p>Here we've got a bug - the <code>newGame</code> function doesn't clear the <code>ChessManager</code>'s moves, it just throws a null reference exception. But we could use this class in our code. In theory if we keep on calling <code>makeMove</code> we'll just grow and grow the <code>moves</code> array. This is a bug leading to memory that can't be freed, even though we don't need it.</p><p>That's a contrived example of a JavaScript memory leak.</p><blockquote><p>When we are finished with memory but don't allow the garbage collector to clean it up, that's a memory leak.</p></blockquote><p>At least for the purposes of this discussion. We'll see it's a very easy thing to do.</p><h3 id=why-is-a-memory-leak-bad>Why is a Memory Leak bad?</h3><p>It might seem obvious but let's just make sure we're explicit with everything. As we said in the initial definition, we allocate memory but don't deallocate it.</p><p>In <em>some</em> circumstances, this is not necessarily a disaster, if we don't leak too much too often, but there are circumstances where this is very serious.</p><p>Memory leaks cause performance problems, slow down applications and can lead to a process terminating. There are some times when that's really not good.</p><p>Servers and high performance applications shouldn't leak, especially as many should be expected to run for long periods of time. Mobile apps or apps for embedded systems will need to deal with fewer resources and will suffer if they leak. Any application an end user is expecting to use for a long time will cause a lot of frustration if it leaks.</p><p>That's enough theory, let's actually start looking at identifying memory leaks in the context of an AngularJS application.</p><h2 id=identifying-memory-leaks>Identifying Memory Leaks</h2><p>I've created a sample app for showing photo albums which is leaky in parts. The app is at:</p><p><a href=http://dwmkerr.github.io/angular-memory-leaks/>dwmkerr.github.io/angular-memory-leaks</a></p><p>It's a very basic app with a fairly common set of components; Bootstrap, jQuery and AngularJS. We're going to take a look at how we can identify whether this app suffers from memory leaks.</p><p>You can run the app in your browser, or run it locally with the commands:</p><pre><code>git clone https://github.com/dwmkerr/angular-memory-leaks.git 
cd angular-memory-leaks
npm install &amp;&amp; bower install
gulp
</code></pre><p>Running gulp will serve the app, lint, and reload the browser when you change the code. The project page is at <a href=https://github.com/dwmkerr/angular-memory-leaks>github.com/dwmkerr/angular-memory-leaks</a>.</p><h3 id=method-1-the-wrong-way>Method 1: The Wrong Way</h3><p>First, just be aware that the wrong way to look for leaks is by examing the memory usage of the Chrome process. While an increasing amount of memory usage <em>can</em> indicate a leak, it is not reliable. Why?</p><p>Well browsers can allocate memory and use it how they want to. A page it is rendering may no longer need as much memory as it needed before, but that doesn't mean the browser needs to release it to the OS. It may just keep it to avoid having to re-allocate it later on.</p><h3 id=method-2-the-timeline>Method 2: The Timeline</h3><p>Open the Chrome developer tools. Go to &lsquo;Timeline&rsquo; select &lsquo;Memory&rsquo; and hit &lsquo;Record&rsquo;.</p><p><img src=images/StartRecording.png alt="Start Recording"></p><p>Now start using your application. After you are done, stop recording. You'll see a graph of memory usage.</p><p><img src=images/MemoryUsage.png alt="Memory Usage"></p><p>This is <strong>almost</strong> exactly what we need. I'll explain the almost shortly, but lets take a look at this graph.</p><ol><li>We see a <em>Used JS Heap</em> in blue. <em>Used</em> is important here - Chrome is telling us that there may be more heap usage than shown in its actual process, but what we are seeing here is what is actually used by the page.</li><li>We see documents (in this case a steady value of one document).</li><li>We see DOM nodes. As I use the app the nodes increase, up until a certain point and then they drop.</li><li>We see Listeners (i.e. even handlers). Again, these increase as I use the app and then drop.</li></ol><p>So what should we be looking for in this graph? That depends on what our app is doing. But let's imagine the we are navigating through different photo albums in the albums app. We'll need more memory to see each album, but once we leave an album we don't need that memory any more. So we should get a healthy saw-tooth pattern<sup><a href=#fn3 id=ref3>3</a></sup>:</p><p><img src=images/TimelineSawtooth.png alt="Timeline Sawtooth"></p><p>Here we see that we use more and more memory, up until the point that Chrome garbage collects, then goes back to where we started. This is repeated again and again. This is a good sign - when Chrome garbage collects we go back to the same place we started, a strong indication we are not leaking much memory.</p><p>If we are doing some work which simply needs more and more memory, and we don't release it, we would expect to see steps instead<sup><a href=#fn4 id=ref4>4</a></sup>:</p><p><img src=images/TimelineSteps-1.png alt="Timeline Steps"></p><p>An example of this might be an infinite scroll situation. I'm looking through a vast photo album, and when I get to the bottom of the screen I load more images automatically. The ones I've loaded are still in the DOM so cannot be released. We see no saw-tooth because there's no release of memory. However, this is not a memory leak - it's just increasing memory usage. It does mean that if we allow the user to scroll too much we may run out of resources though.</p><p>The <strong>dangerous</strong> case is the one below:</p><p><img src=images/TimelineLeakySawtooth.png alt="Leaky Sawtooth"></p><p>Let's imaging we're using the application, navigating through albums, returning the the home page, looking through some more albums and so on. We keep using memory, and Chrome keeps on garbage collecting, but we never quite get back to where we started. We are trending towards increasing memory usage. This indicates we <em>might</em> be leaking memory.</p><p><em>Might</em> is not going to cut the mustard, we need to know categorically what is going on and whether we have a leak.</p><blockquote><p>You said this is &lsquo;almost&rsquo; exactly what we need?</p></blockquote><p>Unfortunately, you cannot always trust this graph. See Mystery 1 for the ugly details. Suffice to say that what we're seeing here is an indicator only, but for more detail we need to look at Method 3.</p><h3 id=method-3-recording-heap-allocations>Method 3: Recording Heap Allocations</h3><p>Let's look at a different way of seeing if we've got a leak, the &lsquo;Heap Allocations&rsquo; view. In the developer tools, go to &lsquo;Profiles&rsquo; and &lsquo;Record Heap Allocations&rsquo;:</p><p><img src=images/HeapAllocations.png alt="Record Heap Allocations"></p><p>When we record heap allocations we get a chart showing us spikes as we allocate memory. These spikes are initially blue (meaning Chrome is using the memory), then change to grey once the memory is freed. If we see spikes or sections of spikes that remain blue, we may have a problem.</p><p>Try this, go to the Ablums app and start recording. Click on the &lsquo;India&rsquo; album, then go back to the home page. You should see a chart like this:</p><p><img src=images/HeapAllocationsEx1.png alt="Heap Allocations Example 1"></p><p>So we start recording and nothing is being allocated. Then we click on the &lsquo;India&rsquo; album (point 1) and we get a few spikes, as chrome allocates memory needed for the content in the new page. Then we click back on the home page (point 2). Some of the memory used in the India album is released (it looks like about half). One spike of memory used for the home page is still in use (what we'd expect) and another spike or two seem to be freed. These other spikes might be memory used for the actual transition, for example in logic in the router.</p><p>So this looks like we may have a problem in the album page. In fact, we can drag a selection box around those first three spikes and see what is <em>still</em> in memory (i.e. what might be a potential leak) in the view below:</p><p><img src=images/HeapAllocationsEx2.png alt="Heap Allocations Example 2"></p><p>Dissecting this view we have:</p><ol><li>A subset of the data, the blue spike from the album page which is still in use.</li><li>The &lsquo;Heap View&rsquo;, which shows us different <em>types</em> of data in memory. Don't worry, we'll see a lot more on this later.</li><li>An instance of a specific type of data, in this case an instance of a JavaScript object.</li><li>The retainers graph for the specific object.</li></ol><p>We're going to look into what all of this means in a lot of detail as we go through the article. For now, I'll simply state what we're seeing, by the end of the article you'll be able to analyse this (and much more) yourself.</p><p>In this snapshot we see a small amount of data still in use. A quick look through the data reveils we have data still in use which relats to the AngularJS template cache.</p><p>This is good! It means this is probably not a leak. When I first visit the album page AngularJS is caching the template used to render it, so of course it stays in memory.</p><blockquote><p>When analysing memory usage remember that caching, preloading and other optimisation techniques may cause some noise.</p></blockquote><p>So if we have the albums page in a cache, in theory the next time we visit the page and then return to the home page, we should free a lot more of the memory (because the <em>new</em> memory we allocate will be just for the page itself, not the cache which is already set up). Let's try it. We'll record going to the album page, back to the homepage, then the album page and back again:</p><p><img src=images/HeapAllocationsEx3.png alt="Heap Allocations Example 3"></p><p>This is looking good.</p><ol><li>We go to the &lsquo;India&rsquo; album. Some memory used is now freed, but much is still in use. As we saw, at least some of that is the template cache.</li><li>We go back to the home page, lots of memory is used but by the time we're done recording it's almost entirely freed.</li><li>We visit the India album a second time, requiring some memory almost all of which is freed.</li><li>We go back to the home page. Some memory is used during the transition and to render the page, some of that is still in use (which is expected as the page is still open).</li></ol><p>The heap allocations chart is exceptionally useful in identifying memory leaks, it has already led to some insights:</p><ol><li>Initial loading of pages increases our &lsquo;baseline&rsquo; memory footprint due to data being added to caches (such as the AngularJS template cache).</li><li>Subsequent loading of pages requires memory, but the vast majority of it is freed.</li></ol><p>One thing we noticed from this brief analysis was that the initial result was slightly misleading. With the heap allocations view repeated operations can help you identify trends. In the Albums application I've actually set up part of the app to run repeated operations, so we can try to consistently test scenarions. The &lsquo;scenarios&rsquo; menu lets us run them. Let's try running scenario 1.</p><p><img src=images/Scenario1.png alt="Scenario 1"></p><p>This scenario will navigate from <code>/</code> (the home page) to <code>/nowhere</code> ten times. <code>/nowhere</code> isn't matched by the router so takes us back to the home page. This has the effect of reloading the home page 20 times (just reloading doesn't work, the router is smart enough to realise we're staying on the same page).</p><p><img src=images/Scneario1HeapAllocations.png alt="Scenario 1 Heap Allocations"></p><p>While you are recording the chart you can see peaks go from blue to grey as memory is freed. Let's see what we've got.</p><ol><li>Shows our first navigation, some memory is not freed. Everything before this is setup code.</li><li>Our last navigation. Some memory still in use (as expected).</li><li>A glance at memory in use shows some compiled code and system data (more on this later). At this stage we don't need to worry, Chrome will allocate data like this when it needs to.</li><li>It looks like the 11th page load didn't free all of it's memory. This is potential cause for worry.</li></ol><p>Altogether this a very healthy looking scenario. The huge majority of what we allocate is freed, as we would hope. Small amounts of memory stay in use (mostly used under the hood by Chrome) and a small amount of memory after the 11th reload is not freed (a quick look suggests a timing issue, definitely something we'd want to investigate further in a real-world app). Our allocations are in the 50 KB to 100 KB range and we're looking good.</p><p>Before we say goodbye to the Heap Allocations view (for now) let's do the same for Scenario 2 (moving from the home page to the top rated page 10 times).</p><p><img src=images/Scenario2HeapAllocations.png alt="Scenario 2 Heap Allocations"></p><p>We are not going to analyse this issue (yet!) but this is an example of a much less healthy chart. In this chart we seem to be allocating memory for each page view and not releasing it. This kind of chart definitely indicates that there could be problems.</p><p>So we've seen the Heap Allocations view, which is a bit more sophisticated than the memory usage graph. Let's look at the last way to analyse memory leaks - snapshots.</p><h3 id=method-4-heap-snapshots>Method 4: Heap Snapshots</h3><p>The final method of identifying memory leaks is the most sophisticated and finely controlled. We will take snapshots at specific points in time and analyse the differences between them. To take a snapshot, we go to the Profiles view and choose &lsquo;Take Heap Snapshot&rsquo;:</p><p><img src=images/TakeHeapSnapshot.png alt="Take Heap Snapshot"></p><p>When we take a heap snapshot Chrome simply records the details of all memory allocated.</p><blockquote><p>Remember: Taking a Snapshot <strong>always</strong> runs garbage collection first.</p></blockquote><p>A heap snapshot shows you exactly the same kind of data you get in the Heap Allocations view, except that you are seeing ALL memory in use, not just objects which were allocated and are still alive:</p><p><img src=images/HeapSnapshot1.png alt="A Heap Snapshot"></p><p>This view is very complete but not necessarily very useful. There's some extra ways to see the data (if you change from &lsquo;Summary&rsquo; to another view or change &lsquo;All Objects&rsquo; but we'll see that later).</p><p>Staying on topic, we'll not yet look in detail at what the data is that we are seeing, we'll first look into identifying whether there are memory leaks - then we'll look into tracking them down.</p><p>Indivdiual snapshots are not so helpful for checking for leaks, but what is very helpful is the ability to compare memory used between snapshots.</p><p>Let's take some snapshots, try this:</p><ol><li>Open the app.</li><li>Navigate to the top rated page (caches should now be set up).</li><li>Navigate to the home page. Take a snapshot.</li><li>Navigate to the top rated page. Take a snapshot.</li><li>Navigate to the home page. Take a snapshot.</li></ol><p>Now we can do something really cool. Select snapshot 3, and choose to view data allocated between snapshot 1 and 2. This means we're seeing data allocated for the top rated page, which is <em>still</em> in use when we go back to the home page, i.e. probably leaked.</p><p><img src=images/SnapshotComparison.png alt="Snapshot Comparison"></p><p>So what are we seeing now?</p><ol><li>We have three snapshots. The size of each one is shown. <em>Sometimes</em> the very first one seems overly high. See Mystery 2. We have selected the 3rd snapshot and are therefore only able to see data still present in this snapshot.</li><li>We are chosing to show only objects allocated between Snapshot 1 and 2, i.e. objects allocated to present the page. But we're <strong>in</strong> snapshot 3, so we're seeing those objects which were allocated and are still present.</li><li>Objects allocated are looking suspicious - we've got DOM elements. This doesn't look good!</li></ol><p>This is the best way to identify memory leaks. So now that we've seen how to identify whether we have memory leaks, or at least that we have a potential problem to analyse we can move onto step 2 - Analysing Memory Leaks.</p><h2 id=analysing-memory-leaks>Analysing Memory Leaks</h2><p>If we think we have a memory leak, we need to be able to look at the heap data and see what's going on. Whether we are seeing heap data from a selection of allocations from the Heap Allocations view or from the Heap Snapshots, we see the same kind of information:</p><p><img src=images/HeapData.png alt="Heap Data"></p><p>Starting from the left we have the &lsquo;Constructor&rsquo; column. This is the type of object we have. Some of these objects we can see are JavaScript classes (constructed with a <code>new</code> call to a function), such as <code>Scope</code>. As well as our own classes, we have some special classes of data:</p><ul><li>(compiled code): Represents JavaScript code compiled by Chrome. Consider this internal - we have no control over it.</li><li>(array): Internally used array object. Again, internal.</li><li>Array: A JavaScript array. Often we have a <em>lot</em> of data in arrays.</li><li>Object: A plain old JavaScript object.</li><li>(closure): A closure.</li><li>system / Context: The underlying data require to call a function, for example the actual data used by a closure.</li><li>system: Internally used data.</li></ul><p>There are also plenty of objects that are created by Chrome, such as <code>HTMLDivElement</code>, which is a wrapper around the internally used (native) DOM object.</p><p>Let's dissect some of these objects in detail. Running <strong>Scenario 3</strong> allocates some data and puts it on the <code>window</code> object. This is really trivial data but shows a lot. You can use the Heap Allocations View or Heap Snapshots to see the data. I've taken three snapshots (once before pressing OK, once after the data is allocated, and the final one when the last modal is closed):</p><p><img src=images/HeapDataAnalysis2.png alt="Heap Data Analysis Part 1"></p><p>This data has come from the code below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>//  Create a class which will hold heap data. Makes it easier 
</span><span style=color:#75715e></span><span style=color:#75715e>//  to find the data in Chrome.
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>HeapData</span>() {}

<span style=color:#75715e>//  Create a heap data object.
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>heapData</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HeapData</span>();

<span style=color:#75715e>//  Create a function that multiplies two numbers.
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>multiply</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>b</span>;
}

<span style=color:#75715e>//  Create a &#39;multiply by&#39; function, which curries the above
</span><span style=color:#75715e></span><span style=color:#75715e>//  to generate a function which multiplies by a constant. This
</span><span style=color:#75715e></span><span style=color:#75715e>//  will involve closures. 
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>multiplyBy</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>a</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>b</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>multiply</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>); 
  }
};

<span style=color:#75715e>//  Add some data to our heap data object.
</span><span style=color:#75715e></span><span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>fry</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Philip J. Fry&#34;</span>;
<span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>zoidberb</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;John &#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;Zoidberg&#34;</span>;
<span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>character</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>firstName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Amy&#34;</span>,
  <span style=color:#a6e22e>secondName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Wong&#34;</span>
};
<span style=color:#a6e22e>heapData</span>.<span style=color:#66d9ef>double</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>multiplyBy</span>(<span style=color:#ae81ff>2</span>);
<span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>multiplyBy100</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>multiplyBy</span>(<span style=color:#ae81ff>100</span>);
<span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>doubledNumber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>heapData</span>.<span style=color:#66d9ef>double</span>(<span style=color:#ae81ff>18</span>);
<span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>multipliedNumber</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>multiplyBy100</span>(<span style=color:#ae81ff>15</span>);
<span style=color:#a6e22e>heapData</span>.<span style=color:#a6e22e>div</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#34;div&#34;</span>);

<span style=color:#75715e>//  Put the heap data on the window, it is now pinned to a GC root.
</span><span style=color:#75715e></span>window.<span style=color:#a6e22e>heapData</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>heapData</span>;
</code></pre></div><p>We've got a little bit of everything here, some code, some closures, some objects and a DOM element.</p><p>As we've put most of this data on the <code>heapData</code> object, which is an instance of <code>HeapData</code> we can easily find the object:</p><p><img src=images/HeapDataAnalysis3.png alt="Heap Data Analysis 3"></p><p>So we can see the <code>HeapData</code> constructor, expanding it we see an <em>instance</em> of <code>HeapData</code>. The <code>@420269</code> is a unique ID assigned by Chrome. If we have lots of heap data objects, we can use this to distinguish between them when we're looking at other parts of the snapshot. What else do we see?</p><ol><li><strong>Distance</strong>. How far the instance is from a GC Root. A GC root is anything that can &lsquo;pin&rsquo; objects, for example the <code>window</code> object which holds globals. If put something on <code>window</code> it will never be freed, this is what makes it a GC root. Our distance is 2 as we have <code>HeapData</code> (constructor) to <code>heapData</code> (instance) to <code>window</code>.</li><li><strong>Objects count</strong>. Only valid for the top level nodes, this shows us how many objects of the specified type we have. We have 1 <code>HeapData</code> object.</li><li><strong>Shallow Size</strong>. The size of the data that is directly allocated for the object. Compare this to <em>Retained Size</em>.</li><li><strong>Retained Size</strong>. The size of data this object is retaining. For example, out <code>heapData</code> instance holds a reference to an object which contains two fields <code>firstName</code> and <code>secondName</code>. Our shallow size includes enough data for the reference, the retained size includes the full retained size of the retained object.</li></ol><p>Notice that our instance of <code>HeapData</code> is highlighted in yellow? That's a convenience from Chrome, it's showing us objects which are <strong>directly accessible</strong> from JavaScript. Our object can be accessed via <code>window.heapData</code>, therefore it's directly accessible. Other objects we've created might not be (for example, a variable used in a closure exists and is on the heap, but not directly accessible).</p><p>Let's see some other data we allocated:</p><p><img src=images/HeapDataAnalysis4-1.png alt="Heap Data Analysis 4"></p><p>Now we're looking at closures. We have two closures in yellow next to each other, clicking on one shows the retainer graph. What is going on here?</p><ol><li>Our closure is not a simple thing. It has code (of course), which takes up memory. We won't look into this in detail. It has shared function data (again, internally used and not worth looking into). We also have a reference to a <code>__proto__</code> (a function object has a prototype!). Finally, we have the context, which contains enough data to call the function. If we look in to the context we will not see much, as our function contains numbers which Chrome can simply store in the code. However, if we use references in closures we'll actually see them in the context.</li><li>We also have the retainers. Our closure is referenced via a variable called <code>multiplyBy100</code>, which itself is referenced by <code>heapData</code>, which if referenced by the <code>window</code> GC root.</li><li>The <code>multiplyBy100</code> variable is <em>also</em> dominated by the second element of an array with id <code>@227339</code>.</li></ol><p>The last thing we'll look at in this snapshot is the div element.</p><p><img src=images/HeapDataAnalysis5.png alt="Heap Data Analyis 5"></p><p>We can see the div element is retained by the <code>div</code> variable in the <code>heapData</code> object. We can also see it is made up of a prototype and some native object. The native object shows no size - don't be fooled. That just means its taking up no JavaScript heap memory. It is still using memory (just in V8 engine not the JavaScript code).</p><p>What's important to note here is that the element is shown in red. This means it's <strong>detached</strong>. So it exists, is referenced (and therefore cannot be garbage collected) but is not in the DOM. This is not necessarily a problem, but lots of detached DOM elements is often a bad sign, especially if the number is increasing.</p><p>The rest of the data you can look through yourself. You'll notice some interesting things, such as how concatenated strings work, but the important stuff we've now seen.</p><p>Let's move on to analyising the first potential memory leak we discovered - the transition to the Top Rated page of the albums app.</p><h3 id=analysing-the-leak-in-scenario-2>Analysing the leak in Scenario 2</h3><p>We saw that <strong>Scenario 2</strong> (switching to and from the &lsquo;top rated&rsquo; view) seemed to leak memory. Let's use the heap snapshot comparison view to analyse this further. The steps are:</p><ol><li>Navigate to the home page.</li><li>Navigate to the top rated page (setting up the cache).</li><li>Navigate to the home page, take a snapshot.</li><li>Navigate to the top rated page, take a snapshot.</li><li>Navigate to the home page, take a snapshot.</li></ol><p>We can now look at the memory allocated between 1 and 2 which is present in 3 (i.e. what we allocated for the top rated view and potentially leaked):</p><p><img src=images/Scenario2Snapshot1.png alt="Scenario 2 Snapshot 1"></p><p>Some things jump out immediately:</p><ol><li>We have gone from 7.5 to 8.4 to 8.5 MB. We are changing from one view to another - and ending in the same place that we started. We <strong>should</strong> be going back to 7.5 MB.</li><li>We've got a lot of objects still hanging around, not just system data like compiled code, but HTML elements, detached DOM elements, <code>Promise</code> objects, <code>n.fn.init</code> objects and so on.</li></ol><p>This looks like a classic leak situation. Let's start by looking at some objects we recognise. There are some <code>Scope</code> objects near the top of the chart, let's look at those.</p><p><img src=images/Scenario1Part2.png alt="Scenario 2 Part 2"></p><p>We've got some <code>Scope</code> objects, three in fact. These objects contain the usual AngularJS fields such as <code>$parent</code>, the only field which distinguishes this scope is the <code>album</code> field. If we look at out <code>aml-rated-album</code> directive it looks like it could be the isolated scope for this directive:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>.<span style=color:#a6e22e>directive</span>(<span style=color:#e6db74>&#39;amlRatedAlbum&#39;</span>, <span style=color:#66d9ef>function</span>() {
  <span style=color:#66d9ef>return</span> {
    <span style=color:#a6e22e>restrict</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;E&#34;</span>,
    <span style=color:#a6e22e>scope</span><span style=color:#f92672>:</span> {
      <span style=color:#a6e22e>album</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=&#34;</span>
    } <span style=color:#75715e>// etc
</span></code></pre></div><p>This scope has an <code>album</code> field. There are three albums so it looks likely these are the three albums in the top rated page, the scopes stil in memory. What retains them?</p><p>Looking at the retainers (at <strong>2</strong>) we don't see much. We're retained by a <code>$$ChildScope</code>, which also retained by a <code>$$ChildScope</code> object. In fact we have quite a complex graph of objects.</p><blockquote><p>When we leak a scope in AngularJS, we leak a huge graph of objects.</p></blockquote><p>Scopes know about their parents. They also know about their children, and siblings. If we inadvertantly pin a scope to a GC root, we <strong>will probably leak almost all of the scopes in the page</strong>.</p><p>Why? The graph below should show why. I &lsquo;leak&rsquo; a scope, and by doing so I retain all of the other scopes, because they are connected. Having a connected graph of scopes is required for angular to work, but it means that we we are extremely susceptible to leaking a <strong>lot</strong> of data.</p><p><img src=images/ScopeLeakGraph1.png alt="Scope leak graph"></p><p>This graph shows <code>$parent</code> retained relationships, but don't forget scopes also know about their children and their siblings, so real graph is even more highly connected.</p><p>So just grabbing a specific scope is not good enough. We need to try and be a little bit more specific. Let's try starting from an element instead. Here we take a look at a div element and its retainers:</p><p><img src=images/Scenario2Part3.png alt="Scenario 2 Part 3"></p><p>Resting the mouse over the instance of a leaked <code>HTMLElement</code> shows a bit of data about it, it's a <code>aml-rated-album</code> and it is detached. Definitely a symptom of our leak. Let's see the retainers:</p><p><img src=images/Scenario2Part4-1.png alt="Scenario 2 Part 4"></p><p>Ouch. This is nasty. Again, we are not seeing much that is particularly useful. We have a long graph of retainers starting with the <code>compileNode</code> function, we also have an array in a <code>n.fn.init</code> function. To cut a long story short, we're are not going to easily find the root cause here. But I will share some hints.</p><blockquote><p>jQuery isn't leaking.</p></blockquote><p>We will end up seeing so much jQuery stuff it is natural to wonder whether jQuery is leaking. Almost certainly not. In the graph about <code>n.fn.init</code> is just a jQuery selector, held onto by <code>$$element</code>. No surprise - all angular elements are jQuery or jQuery light objects. We've leaked an element, it just happens to be wrapped in a jQuery selector. (You might see a different type of graph, probably due to the jQuery 1 + AngularJS 1.2 combination, we'll see it later).</p><p>You may see low level arrays containing data associated with a scope in jQuery, again, don't worry. It's the jQuery data cache (which we'll also see later), which is associating elements to scopes.</p><p>We can try and work through this graph, but let's try another tack.</p><p>It looks like we're probably leaking the whole of the top rated view. We're probably leaking the main scope for the view, created by the <code>TopRatedController</code>. Let's see if we can find it.</p><blockquote><p>You can find objects you think are leaking by tagging them with classes!</p></blockquote><p>This is a neat trick. Let's add a couple of lines to our top rated controller:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>angular</span>.<span style=color:#a6e22e>module</span>(<span style=color:#e6db74>&#39;app&#39;</span>)
.<span style=color:#a6e22e>controller</span>(<span style=color:#e6db74>&#39;TopRatedController&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>$scope</span>, <span style=color:#a6e22e>$http</span>, <span style=color:#a6e22e>$interval</span>) {

  <span style=color:#75715e>//  Create a class, assign it to the scope. This&#39;ll help us 
</span><span style=color:#75715e></span>  <span style=color:#75715e>//  see if $scope is leaked.
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>TopRatedControllerTag</span>() {}
  <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>__tag</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TopRatedControllerTag</span>();
  
  <span style=color:#75715e>//  etc...
</span><span style=color:#75715e></span>});
</code></pre></div><p>Now when we run the analysis again, we can search in the snapshot for <code>TopRatedControllerTag</code>:</p><p><img src=images/Scenario2Part5.png alt="Scenario 2 Part 5"></p><ol><li>We search for &lsquo;Tag&rsquo;, finding one instance of the <code>TopRatedControllerTag</code>.</li><li>Bingo - it is retained by a Scope, with id <code>@534851</code></li></ol><p>Let's look at this scope in more detail. Right click on it and choose &lsquo;Review in Summary View&rsquo;, so we can see what is retaining it:</p><p><img src=images/Scenario2Part6.png alt="Scenario 2 Part 6"></p><ol><li>We can now see the root scope for the actual view.</li><li>We can see the usual pattern of <code>$$ChildScope</code> and <code>$parent</code> properties, but what else have we got?</li></ol><p>Intestingly we can see that our scope is also retained by a <strong>context variable called $scope</strong>. How do I know it is a context variable? It's in blue, part of the colour coding (see Mystery 3).</p><p>What is a context variable?</p><blockquote><p>A <strong>closure</strong> is a function which refers to a variable outside of its definition. A <strong>context variable</strong> is the variable stored in a function context. A <strong>function context</strong> contains the environment for a closure, which is the data required to execute it.</p></blockquote><p>So basically we have a closure which refers to a variable called <code>$scope</code>, which is the root scope of our view. We can see in detail the closure:</p><p><img src=images/Scenario2Part7.png alt="Scenario 2 Part 7"></p><ol><li><code>$scope</code> is retained by a <code>context</code> for a closure.</li><li>The closure is in the <code>refresh</code> function (this is why the <code>context</code> is retained by <code>refresh</code>).</li></ol><p>We can open the function and examine it for issues. There's an <code>$http.get</code> which has as closure which uses <code>$scope</code>, but alarmingly there is an <code>$interval</code> registered to run every 10 seconds, which is never deregistered. The interval callback uses another <code>$http.get</code>, with a closure that uses <code>$scope</code>. This is the problem.</p><p>A simple timeout we forgot to deregister has a closure on <code>$scope</code>. <code>$scope</code> can therefore never be cleaned up, because it is retained by a context.</p><p>Some important takeaways:</p><ol><li>The framework hides implementation details. Often useful, but in this case it made finding the leak a problem.</li><li>This example seems contrived, but how how often do you have a closure using <code>$scope</code> in a controller? In real world apps all of the time time, callbacks to ajax requests, event handlers, promise functions etc.</li><li>A leak of a small object that contains the <strong>data</strong> for three albums has leaked a <strong>large graph</strong> of other objects, and even <strong>DOM elements</strong>.</li></ol><blockquote><p>Leaks are not incremental. You don't get an accumulation of small leaks, one small leak can retain a huge graph.</p></blockquote><p>Let's talk about this a bit more.</p><h3 id=dealing-with-object-graphs>Dealing with Object Graphs</h3><p>We saw before that a chain of retainers can pin an object, such as a scope, to a GC root. We also saw that AngularJS scopes are part of a highly connected graph, meaning that if we leak part of it, we probably leak it all:</p><p><img src=images/ScopeLeakGraph1-1.png alt="Scope Leak Graph 1"></p><p>However, things can get worse. Remember how in an angular app you can get the scope for an element with <code>$(selector).scope()</code>? This connection between a scope an an element is maintained in the jQuery data cache. This lets us associate arbitrary data with an element. This introduces another layer of connectivity:</p><p><img src=images/ScopeLeakGraph2.png alt="Scope Leak Graph 2"></p><p>In this graph, we see the jQuery data cache entries (in grey) associating DOM elements to scopes, introducing more connectivity.</p><p>We can see here an alarming increase in the size and potential complexity of the graph. We've got DOM elements in play now. The chances are that if you are reading this you are dealing with a memory leak in your app, if it's noticable enough for you to deal with it, you probably have a non-trivial graph.</p><p>So how do we fix memory leaks? I'll show three general approaches and how to use each one.</p><h2 id=fixing-memory-leaks>Fixing Memory Leaks</h2><p>Fixing memory leaks is hard. As we have seen our problem is highly connected graphs. If we have a part of the graph we want to free for garbage collection (such as a scope and all of it's children, such as a view or directive) then we must not retain that graph of objects. This means if you have (for example) three problems that lead to retaining a graph, you have to fix <strong>all of the problems</strong> before the leak goes away.</p><p>Let's generalise the best practices first into three rules, see patterns we should follow for each of them and then look at anti-patterns to avoid.</p><h3 id=three-golden-rules>Three Golden Rules</h3><blockquote><p>Rule 1: Understand the framework and lifecycle.</p></blockquote><p>If you are using a framework like AngularJS, you <strong>must</strong> understand the lifecycle of the objects you are dealing with. Unless you understand how the framework tries to clean up, you may make mistakes that stop it from working.</p><blockquote><p>Rule 2: Be careful at the interface between short and long lived objects.</p></blockquote><p>Whenever you see an interface between a short and long lived object, be extra careful. For example, if you have a directive talking to a service, make sure the service cannot retain the directive through closures, callbacks or any references. Services will last for the lifetime of the application, so they are the sort of object which can inadvertantly retain short lived objects.</p><p>Other long lived objects exist but may be more subtle, the interface between AngularJS and other libraries can be a risky area, if other libraries maintain long lived state.</p><p>Finally, consider this. The isolated scope for a directive (for example) may inadvertantly be long lived - if it is leaked. That leads us to Rule 3.</p><blockquote><p>Rule 3: Disconnect the graph.</p></blockquote><p>You can be defensive by manually disconnecting graphs of objects. This can aid if you have a memory leak you cannot resolve. By disconnecting the graph, the garbage collector will at least be able to attempt to clean up parts of it.</p><p>AngularJS should attempt to do this for you, for example when scopes are destroyed the links to other scopes are severed. But you can also do this yourself. Disconnecting the graph is not always as simple as emptying arrays or nulling objects, it can mean nulling closures and context variables too<sup><a href=#fn5 id=ref5>5</a></sup>.</p><p>The anti-patterns which follow are all violations of these rules.</p><h3 id=anti-patterns-to-avoid>Anti-Patterns to Avoid</h3><p>Whether or not your app is suffering from memory leaks, avoid these patterns.</p><h4 id=poorly-managed-event-handlers>Poorly Managed Event Handlers</h4><p>Consider a trivial example in a directive link:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>scope</span>, <span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>attrs</span>) {
  <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>scope</span>.<span style=color:#a6e22e>selected</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
  });
}
</code></pre></div><p>We register an event handler. We've now built a closure which will have a context, which retains the <code>scope</code>. If we don't deregister this event handler, we retain the closure, the context, the scope, and then basically everything in the universe.</p><p><strong>The Fix</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>scope</span>, <span style=color:#a6e22e>element</span>, <span style=color:#a6e22e>attrs</span>) {
  <span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;click&#39;</span>, <span style=color:#66d9ef>function</span>() {
    <span style=color:#a6e22e>scope</span>.<span style=color:#a6e22e>selected</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
  });
  <span style=color:#a6e22e>scope</span>.<span style=color:#a6e22e>$on</span>(<span style=color:#e6db74>&#39;$destroy&#39;</span>, <span style=color:#66d9ef>function</span>() {
  	<span style=color:#a6e22e>element</span>.<span style=color:#a6e22e>off</span>(); <span style=color:#75715e>// deregister all event handlers
</span><span style=color:#75715e></span>  })<span style=color:#e6db74>&#39;&#39;</span>
}
</code></pre></div><p><em>Note:</em> Angular <em>should</em> handle this. It is supposed to deregister event handlers on elements it manages. In my experience this isn't always the case, although it seems cases when this doesn't happen are fewer and fewer as bugs get fixed in the framework. Anyway, Rule 3 - disconnect.</p><h4 id=poorly-managed-watchers>Poorly Managed Watchers</h4><p>Watchers or angular event handlers, basically the same as above.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>$on</span>(<span style=color:#e6db74>&#39;someEvent&#39;</span>, <span style=color:#66d9ef>function</span>() {
	<span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>refresh</span>();
})
</code></pre></div><p>Again, Angular should clean this up if you forget to, but the advice is always do it yourself. Angular watchers return a deregister function.</p><p><strong>The Fix</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cleanup</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>$on</span>(<span style=color:#e6db74>&#39;someEvent&#39;</span>, <span style=color:#66d9ef>function</span>() {
	<span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>refresh</span>();
});
<span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>$on</span>(<span style=color:#e6db74>&#39;$destroy&#39;</span>, <span style=color:#66d9ef>function</span>() {
	<span style=color:#a6e22e>cleanup</span>();
})
</code></pre></div><p>Rule 1 - know the framework and how lifecycle is handled. <code>$destroy</code> is sent to a scope specifically to allow it to be cleaned up.</p><h4 id=callback-functions-on-services>Callback Functions on Services</h4><p>Services (or other long lived objects) should typically not take callback functions. Imagine a &lsquo;user service&rsquo;, allowing a scope to discover if the user has changed their name:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>UserService</span>.<span style=color:#a6e22e>onNameChange</span>(<span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>newName</span>) {
	<span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>userName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newName</span>;
});
</code></pre></div><p>Now the service (a long lived object) takes a closure with a context to a short lived object, the scope. Unless the service is written absolutely correctly, we run the risk of the service retaining the scope. Remember, services are singletons and as such the interface between services and scopes is one that requires careful management.</p><p>There are two fixes I would suggest.</p><p><strong>Fix 1: For a one-off operation, use a promise</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// change and name and wait for the result
</span><span style=color:#75715e></span><span style=color:#a6e22e>UserService</span>.<span style=color:#a6e22e>changeName</span>(<span style=color:#e6db74>&#34;Fry&#34;</span>).<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>newName</span>) {
	<span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newName</span>;
});
</code></pre></div><p>The notification service returns a promise (a short lived object) which holds the closure. If we get things wrong, we are less likely to leak the scope. Plus, promises are typically easy to work with once you've got the hang of them<sup><a href=#fn6 id=ref6>6</a></sup>.</p><p><strong>Fix 2: For notifications, use broadcasts</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// more like our original example
</span><span style=color:#75715e></span><span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>$on</span>(<span style=color:#e6db74>&#39;NotificationService:ChangeName&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>data</span>) {
	<span style=color:#a6e22e>$scope</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>data</span>;
});
</code></pre></div><p>Some will say to not overuse broadcasts as they can be expensive. They can, so use them judiciously. But remember, they're provided by the framework, typically lead to fairly loose coupling and are probably managing clean up as well or better than a hand-rolled mechanism in a service. Rule 2 - don't tie short lived objects to long lived objects.</p><h2 id=the-future>The Future</h2><p>That's a wrap. Hopefully this article will grow and improve with feedback from the community. To wind up, lets look at a few things that are on their way which will touch on these issues.</p><h3 id=weak-maps>Weak Maps</h3><p>Finally, in ECMAScript 6 we will get a WeakMap<sup><a href=#fn7 id=ref7>7</a></sup> object. This is <em>ideal</em> for something like the jQuery data cache. A weak map uses weak references (not natively supported in JavaScript). This means that we can map a DOM element to a scope in a weak map, but the map entry doesn't retain the element or scope. If the element or scope is cleaned up, the map entry is removed. This means internal structures to aid with frameworks don't need to necessarily retain object graphs.</p><h3 id=angularjs-2>AngularJS 2</h3><p>Simplifications to the framework in 2.0 and usage of native features like web components mean less complex framework code and less scope for issues. Consider even the usage of classes in Angular 2.0. We don't decorate a scope object (of type <code>Object</code>) we create an instance of a class. Easier to see in the heap view.</p><h3 id=even-better-browsers>Even Better Browsers</h3><p>SPA frameworks are driving improvements to browsers. Frameworks like Angular lead to more SPAs. More SPAs mean we find more bugs and edge cases in browsers. Many memory leak issues in AngularJS have led to fixes in V8.</p><h2 id=appendices>Appendices</h2><p>Beware any write up long enough to need appendices.</p><h3 id=thanks>Thanks</h3><p>Much of my understanding here came from working with others on real-world issues. I would like to thank the following people for their advice and insights:</p><p>James Denning, Shaun Bohannon, Arnaud Rebts, Colin Montgomery, Jon Hamshaw, Christian Lilley, Maarten De Wilde</p><p>There are others I have worked on with in this area, if I have forgotten to mention you please let me know.</p><h3 id=mysteries>Mysteries</h3><p>After a large amount of time spent investigating memory leaks, there are still some things which to me are a mystery. If anyone can shed some light, I'd be interested to know.</p><p><strong>Mystery 1: False Charts</strong></p><p>As mentioned earlier we cannot always trust the timeline, it is not uncommon to see the memory usage in the timeline increase, even though the size of snapshots seems to be staying constant. This may be related to AngularJS Issue <a href=https://github.com/angular/angular.js/issues/4864>DOM Nodes Leaking</a>.</p><p><strong>Mystery 2: Odd Snapshot Sizes</strong></p><p>It is not uncommon for the first snapshot to be large, and then subsequent snapshots to all be a bit smaller (even without any state changes). Why this is the case I do not know. To test, run an angular app and take some snapshots without doing anything in between. You'll normally see (for example) 9 MB, 9MB, 9MB. However, it is not uncommon to see 15 MB, 9MB, 9MB.</p><p><strong>Mystery 3: Where's the colour coding documentation?</strong></p><p>The Chrome documentation states that the colour coding key for elements in the heap snapshot is available in the tool. I can't find it anywhere, so had to research to find the details.</p><h3 id=further-reading>Further Reading</h3><p>Still not had enough? Try these.</p><ol><li><a href=https://developer.chrome.com/devtools/docs/heap-profiling#basics>Profiling Memory Performance</a></li><li><a href=https://developer.chrome.com/devtools/docs/memory-analysis-101>Memory Analysis 101</a></li><li><a href=https://developer.chrome.com/devtools/docs/heap-profiling-containment>Heap profile containment</a></li><li><a href=https://developer.chrome.com/devtools/docs/tips-and-tricks>Dev tools tips & tricks</a></li><li><a href=https://developer.chrome.com/devtools/docs/javascript-memory-profiling>JavaScript Memory Profiling</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management>Memory Management</a></li><li><a href=http://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/>Taming the Unicorn</a></li></ol><hr><p><sup id=fn1>1. This is C actually, but the syntax isn't important, just the logic of what we're doing.<a href=#ref1>↩</a></sup>
<sup id=fn2>2. In JavaScript as in most managed languages, the mechanism by which this happens is reference counting and garbage collection. There's a superb description at <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management>JavaScript Memory Management</a>.<a href=#ref2>↩</a></sup>
<sup id=fn3>3. Try it yourself with this <a href=http://jsfiddle.net/dwmkerr/2LzxgLb4/>fiddle for a sawtooth pattern</a>.<a href=#ref3>↩</a></sup>
<sup id=fn4>4. Try it yourself with this <a href=http://jsfiddle.net/dwmkerr/9dmpp5te/>fiddle for a &lsquo;steps&rsquo; pattern</a>.<a href=#ref4>↩</a></sup>
<sup id=fn5>5. See <a href=https://github.com/dwmkerr/angular-modal-service/commit/79998ca98101798608bdb914aecbd44f3ccbaa7a>this commit</a> in my Angular Modal Service for an example of how nulling context variables (i.e. disconnecting the graph) solved a memory leak. This is a good example of how are it can be, after large amounts of analysis I still haven't discovered <strong>why</strong> this was needed, but it solved the problem. It may relate to Mystery 4.<a href=#ref5>↩</a></sup>
<sup id=fn6>6. See my article <a href=http://www.dwmkerr.com/promises-in-angularjs-the-definitive-guide/>Promises in AngularJS - The Definitive Guide</a> if you are not sure how to use them.<a href=#ref6>↩</a></sup>
<sup id=fn7>7. More details at <a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap>https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/WeakMap</a><a href=#ref7>↩</a></sup></p></div><footer class="post-footer clearfix"><p class=post-tags><span>Tagged:</span>
<a href=/dwmkerr.com/tags/AngularJS/>AngularJS</a>,
<a href=/dwmkerr.com/tags/CodeProject/>CodeProject</a>,
<a href=/dwmkerr.com/tags/Javascript/>Javascript</a></p><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Fixing%20Memory%20Leaks%20in%20AngularJS%20and%20other%20JavaScript%20Applications&url=https%3a%2f%2fdwmkerr.github.io%2fdwmkerr.com%2ffixing-memory-leaks-in-angularjs-applications%2f" onclick="window.open(this.href,'twitter-share','width=550,height=235');return false;"><i class="fa fa-twitter"></i><span class=hidden>Twitter</span></a>
<a class=icon-facebook href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdwmkerr.github.io%2fdwmkerr.com%2ffixing-memory-leaks-in-angularjs-applications%2f" onclick="window.open(this.href,'facebook-share','width=580,height=296');return false;"><i class="fa fa-facebook"></i><span class=hidden>Facebook</span></a></div></footer><div class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"dmwkerr"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a title=dwmkerr.com href=https://dwmkerr.github.io/dwmkerr.com/>dwmkerr.com</a></h1><a class="button-square button-jump-top js-jump-top" href=#><i class="fa fa-angle-up"></i></a></div><p class=footer-copyright><span>&copy; 2019 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://dwmkerr.github.io/dwmkerr.com/js/jquery-1.11.3.min.js></script><script src=https://dwmkerr.github.io/dwmkerr.com/js/jquery.fitvids.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://dwmkerr.github.io/dwmkerr.com/js/scripts.js></script></body></html>
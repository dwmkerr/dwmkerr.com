<!doctype html><html prefix="og: http://ogp.me/ns#"><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Simple Continuous Integration for Docker Images &#183; Dave Kerr</title><meta name=description content="In this article I'm going to demonstrate a few tips and tricks which can make your life easier when you are building or maintaining Dockerfiles.
The need for a Build Pipeline Do we really need any kind of continuous integration or build pipeline for Dockerfiles?
There will be cases when the answer is no. However, if the answer to any of the following questions is &lsquo;yes&rsquo;, it might be worth considering:"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=generator content="Hugo 0.61.0"><meta name=robots content="index,follow"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Simple Continuous Integration for Docker Images"><meta property="og:description" content="In this article I'm going to demonstrate a few tips and tricks which can make your life easier when you are building or maintaining Dockerfiles.
The need for a Build Pipeline Do we really need any kind of continuous integration or build pipeline for Dockerfiles?
There will be cases when the answer is no. However, if the answer to any of the following questions is &lsquo;yes&rsquo;, it might be worth considering:"><meta property="og:type" content="article"><meta property="og:url" content="https://dwmkerr.github.io/dwmkerr.com/simple-continuous-integration-for-docker-images/"><link rel=stylesheet href=https://dwmkerr.github.io/dwmkerr.com/dist/styles.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic"><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous></head><body><script type=application/javascript>var dnt=(navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack);var doNotTrack=(dnt=="1"||dnt=="yes");if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-41728580-1','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><div id=wrapper><header class=site-header><div class=container><div class=site-title-wrapper><h1 class=site-title><a title=dwmkerr.com href=https://dwmkerr.github.io/dwmkerr.com/>dwmkerr.com</a></h1><a class=button-square href=https://dwmkerr.github.io/dwmkerr.com/index.xml><i class="fa fa-rss"></i></a><a class="button-square button-social hint--top" data-hint=Twitter title=Twitter href=https://twitter.com/dwmkerr rel=me><i class="fa fa-twitter"></i></a><a class="button-square button-social hint--top" data-hint=Github title=Github href=https://github.com/dwmkerr rel=me><i class="fa fa-github-alt"></i></a><a class="button-square button-social hint--top" data-hint="Stack Overflow" title="Stack Overflow" href=https://stackoverflow.com/users/1189164/dave-kerr rel=me><i class="fa fa-stack-overflow"></i></a><a class="button-square button-social hint--top" data-hint=LinkedIn title=LinkedIn href=https://www.linkedin.com/in/dwmkerr/ rel=me><i class="fa fa-linkedin"></i></a></div><ul class=site-nav><li class=site-nav-item><a title=Blog href=/dwmkerr.com/>Blog</a></li><li class=site-nav-item><a title=Speaking href=/dwmkerr.com/page/speaking/>Speaking</a></li><li class=site-nav-item><a title=About href=/dwmkerr.com/page/about/>About</a></li></ul></div></header><div id=container><div class=container><article class=post-container itemscope itemtype=http://schema.org/BlogPosting><header class=post-header><h1 class=post-title itemprop="name headline">Simple Continuous Integration for Docker Images</h1><p class="post-date post-line"><span>Published <time datetime=2016-11-03 itemprop=datePublished>Thu, Nov 3, 2016</time></span>
<span>by</span>
<span itemscope itemprop=author itemtype=https://schema.org/Person><span itemprop=name><a href=https://github.com/dwmkerr itemprop=url rel=author>Dave Kerr</a></span></span></p></header><div class="post-content clearfix" itemprop=articleBody><img class=post-featured-image src=/images/2016/11/Simple-Docker-Image-CI-1.png><p>In this article I'm going to demonstrate a few tips and tricks which can make your life easier when you are building or maintaining Dockerfiles.</p><h2 id=the-need-for-a-build-pipeline>The need for a Build Pipeline</h2><p>Do we really need any kind of continuous integration or build pipeline for Dockerfiles?</p><p>There will be cases when the answer is no. However, if the answer to any of the following questions is &lsquo;yes&rsquo;, it might be worth considering:</p><ol><li>Do you want others to be able to contribute to the Dockerfile, perhaps changing the image over time?</li><li>Are there specific functionalities in your Dockerfiles which could break if altered?</li><li>Do you expect to need to release updates to your Dockerfile?</li></ol><p>Essentially, if we are looking at providing some kind of automated quality assurance and automation around building and releasing, then a build pipeline is not a bad idea.</p><h2 id=a-simple-build-pipeline>A simple Build Pipeline</h2><p>Here's what a simple build pipeline could look like. This example is for a Docker Image I just created for local DynamoDB development - <a href=https://github.com/dwmkerr/docker-dynamodb>dwmkerr/docker-dynamodb</a>:</p><p><img src=images/Simple-Docker-Image-CI.png alt="Simple Continous Intergration Pipeline"></p><p>Let's dissect what we've got here.</p><h3 id=the-dockerfile>The Dockerfile</h3><p>This is the main &lsquo;code&rsquo; of the project if you like. The <a href=https://github.com/dwmkerr/docker-dynamodb/blob/master/Dockerfile>Dockerfile</a> is the recipe for the image we create.</p><h3 id=the-continuous-integration-service>The Continuous Integration Service</h3><p>In this case, I am using <a href=https://circleci.com/>CircleCI</a>, however the approach described would work fine with most CI systems (such as Jenkins, TravisCI and TeamCity). There <em>is</em> an option to use the <a href=https://docs.docker.com/docker-hub/builds/>Docker Hub Automated Builds</a>, but I've found this doesn't give the flexibility I need (see <a href=#appendix1whynotdockerhubautomatedbuilds>Why not Docker Hub Automated Builds</a>).</p><p>Essentially the CI service needs to offer the option to have three distinct steps in the pipeline, each of which must pass for process to proceed:</p><ol><li>Build</li><li>Test</li><li>Deploy</li></ol><h3 id=the-build>The Build</h3><p>We can build with tools, script files, whatever. At the moment, I am leaning towards <a href=https://www.gnu.org/software/make/>makefiles</a>. Normally I only need a few lines of shell script to do a build - anything more complex and the makefile can call a shell script. See also <a href=#appendix2whymakefiles>Why Makefiles?</a></p><p>Here's what it might look like:</p><pre><code>build:
	docker build -t dwmkerr/dynamodb:latest .
ifndef BUILD_NUM
	$(warning No build number is defined, skipping build number tag.)
else
	docker build -t dwmkerr/dynamodb:$(BUILD_NUM) .	
endif
</code></pre><p>This command just builds the <code>Dockerfile</code> and tags it as <code>dwmkerr/dynamodb:lastest</code>. If a <code>BUILD_NUM</code> variable is present, we also create the tag <code>dwmkerr/dynamodb:BUILD_NUM</code>. This means if we want to deploy to a service such as <a href=https://aws.amazon.com/ecs/>Amazon ECS</a> we can push a specific build by referring to the image with that tag.</p><h3 id=the-tests>The Tests</h3><p>Again I'm relying on <code>make</code>. I just want to be able to run <code>make test</code> - if zero is returned I'm happy. If not, the pipeline should stop and I'll check the output. Here's my test command:</p><pre><code>test: build
	./test/basics.test.sh
	./test/ephemeral.test.sh
	./test/persistent.test.sh
</code></pre><p>Not a thing of beauty, but it works. These scripts I'll discuss a little bit later on, in the delightly titled <a href=#appendix3whatarethesetestscripts>What are these test scripts</a> section.</p><p>For CircleCI, this is enough to have the main part of our pipeline. Here's how the <code>circle.yml</code> file looks at this stage:</p><pre><code>machine:
  services:
  - docker
  environment:
    # Set the build number, used in makefiles.
    BUILD_NUM: $CIRCLE_BUILD_NUM
test:
  override:
    - make test
</code></pre><p>(Actually there's a couple of other bits but they're just to make sure circle uses the right version of Docker, <a href=https://github.com/dwmkerr/docker-dynamodb/blob/master/circle.yml>see the full circle.yml file here</a>).</p><h3 id=the-deployments>The Deployments</h3><p>Deployments are trivial as all we need to do is push to the Docker Hub. The <code>make deploy</code> command looks-a like this:</p><pre><code>deploy: 
	docker push dwmkerr/dynamodb:latest
ifndef BUILD_NUM
	$(warning No build number is defined, skipping push of build number tag.)
else
	docker push dwmkerr/dynamodb:$(BUILD_NUM)
endif
</code></pre><p>We're pushing the <code>latest</code> tag and <code>BUILD_NUM</code> tag if present. To add this to the CircleCI pipeline, we just add the following to <code>circle.yml</code>:</p><pre><code>deployment:
  master:
    branch: master
    commands:
      - docker login -e $DOCKER_EMAIL -u $DOCKER_USERNAME -p $DOCKER_PASSWORD
      - make deploy
</code></pre><p>If we have a push to <code>master</code>, we log in to Docker (using environment variables I configure in the CircleCI UI) and then run <code>make deploy</code> to push our images.</p><h2 id=thats-it>That's It</h2><p>That's about it. This is a pretty simple approach, you can see it in action at:</p><p><a href=https://github.com/dwmkerr/docker-dynamodb>github.com/dwmkerr/docker-dynamodb</a></p><p>The rest of this post is a bit of a deep dive into some specific areas I found interesting.</p><h2 id=appendix-1-why-not-docker-hub-automated-builds>Appendix 1: Why not Docker Hub Automated Builds?</h2><p>There are automated builds available in the Docker Hub:</p><p><img src=images/dockerhubbuilds.png alt="Docker Hub Automated Builds"></p><p>I'm not using this feauture at the moment, here's a brief roundup of what I think are the current pros and cons:</p><p>Pros</p><ul><li>You don't have to goof around installing Docker on a CI platform.</li><li>It allows you to update the description of your Docker image automatically, from the GitHub <code>README.md</code>.</li><li>It allows you to associate the image with a specific GitHub repo (rather than just linking from the image description).</li><li>Branch management - allowing tags to be built for specific branches.</li></ul><p>Cons</p><ul><li>It doesn't <em>seem</em> to support any kind of configurable gating, such as a running a test command prior to deploying.</li><li>It doesn't <em>seem</em> to support any kind of triggering of downstream processes, such as updating environments, sending notifications or whatever.</li></ul><p>The lack of ability to perform tests on the image before deploying it why I'm currently not using the service.</p><p>By doing the testing in a CI system for every pull request and only merging PRs where the tests pass we could mitigate the risk here. This service is worth watching as I'm sure it will evolve quickly.</p><h2 id=appendix-2-why-makefiles>Appendix 2: Why Makefiles?</h2><p>I started coding with a commandline compiler in DOS. When I used my first GUI (Borland Turbo C++) it felt like a huge leap:</p><p><img src=images/turbocpp.png alt="Borland Turbo C++"></p><p>Later on I moved onto Microsoft Visual C++ 4.2:</p><p><img src=images/visualcpp.png alt="Visual C++ 4.2"></p><p>And you cannot imagine the excitement when I got my boxed edition of Visual Studio .NET:</p><p><img src=images/visualstudiodotnet.jpg alt="Visual Studio .NET"></p><p>Wow!</p><p>Anyway, I digress. GNU <code>make</code> was invented by Leonardo Da Vinci in 1473 to allow you to build something from the commandline, using a fairly consistent syntax.</p><p>It is near ubiquitous on *nix systems. I am increasingly using it as an &lsquo;entry point&rsquo; to builds, as I use variety of languages and platforms. Being able to know that most of the time:</p><pre><code>make build
make test
</code></pre><p>Will build and test something is convenient. Makefiles actually are not that great to work with (see <a href=http://stackoverflow.com/questions/448910/makefile-variable-assignment>this</a>, <a href=http://stackoverflow.com/questions/10121182/multiline-bash-commands-in-makefile>this</a> and <a href=http://www.conifersystems.com/whitepapers/gnu-make/>this</a>). I've found as long as you keep the commands simple, they're OK. For anything really complex, I normally have a <code>scripts/</code> folder, but call the scripts <em>from</em> the makefile, so that there's still a simple entrypoint.</p><p>I'm not entirely sold on makefiles, but they tend to be my default at the moment if I know I'm going to use the commandline for builds (for example, in Java projects I'll often write a makefile to call Maven or Gradle).</p><p>For things like Node.js, where you have commands like <code>npm test</code> or <code>npm run xyz</code> I <em>still</em> sometimes use makefiles, using <code>npm</code> for day-to-day dev tests (<code>npm start</code>) and <code>make</code> if it's something more complex (e.g. <code>make deploy-sit</code> to deploy to an SIT environment).</p><h2 id=appendix-3-what-are-these-test-scripts>Appendix 3: What are these test scripts?</h2><p>You may have noticed:</p><pre><code>test: build
	./test/basics.test.sh
	./test/ephemeral.test.sh
	./test/persistent.test.sh
</code></pre><p>What's going on here?</p><p>My Docker image is just a wrapper around <a href=http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html>Amazon's Local DynamoDB tool</a>. I don't really need to test that tool. But what I wanted to test was the capabilities which lie at the <em>intersection</em> between &lsquo;native&rsquo; Docker and &lsquo;native&rsquo; DynamoDB.</p><p>For example, I know Docker supports volume mapping. I know DynamoDB supports using a data directory, to allow persistent between runs. I want to test I can combine Docker volume mapping and the DynamoDB data directory features. I know Docker images should default to being ephemeral, I want to test this holds true by default for my image.</p><p>Testing Docker is a little hard - I want to test that I can run containers, start, stop, check state before and after and so on. This is essentially an integration test, it can be tricky to make it truly isolated and deterministic.</p><p>I've given it my best go with these scripts. Here's an example for the &lsquo;ephemeral&rsquo; test, where I'm trying to assert that if I run a container, create a table, stop the container and run a new one, I no longer have the table. Here's the test:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># Bomb if anything fails.</span>
set -e

<span style=color:#75715e># Kill any running dynamodb containers.</span>
echo <span style=color:#e6db74>&#34;Cleaning up old containers...&#34;</span>
docker ps -a | grep dwmkerr/dynamodb | awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> | xargs docker rm -f  <span style=color:#f92672>||</span> true

<span style=color:#75715e># Run the container.</span>
echo <span style=color:#e6db74>&#34;Checking we can run the container...&#34;</span>
ID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>docker run -d -p 8000:8000 dwmkerr/dynamodb<span style=color:#66d9ef>)</span>
sleep <span style=color:#ae81ff>2</span>

<span style=color:#75715e># Create a table.</span>
aws dynamodb --endpoint-url http://localhost:8000 --region us-east-1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	create-table <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	--table-name Supervillains <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --attribute-definitions AttributeName<span style=color:#f92672>=</span>name,AttributeType<span style=color:#f92672>=</span>S <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	--key-schema AttributeName<span style=color:#f92672>=</span>name,KeyType<span style=color:#f92672>=</span>HASH <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	--provisioned-throughput ReadCapacityUnits<span style=color:#f92672>=</span>1,WriteCapacityUnits<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>

<span style=color:#75715e># Clean up the container. On CircleCI the FS is BTRFS, so this might fail...</span>
echo <span style=color:#e6db74>&#34;Stopping and restarting...&#34;</span>
docker stop $ID <span style=color:#f92672>&amp;&amp;</span> docker rm $ID <span style=color:#f92672>||</span> true
ID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>docker run -d -p 8000:8000 dwmkerr/dynamodb<span style=color:#66d9ef>)</span>
sleep <span style=color:#ae81ff>2</span>

<span style=color:#75715e># List the tables - there shouldn&#39;t be any!</span>
COUNT<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>aws dynamodb --endpoint-url http://localhost:8000 --region us-east-1 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    list-tables <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	| jq <span style=color:#e6db74>&#39;.TableNames | length&#39;</span><span style=color:#66d9ef>)</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> $COUNT -ne <span style=color:#e6db74>&#34;0&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
    echo <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Expected to find no tables, found </span>$COUNT<span style=color:#e6db74>...</span><span style=color:#e6db74>&#34;</span>
	exit <span style=color:#ae81ff>1</span>
<span style=color:#66d9ef>fi</span>
</code></pre></div><p>It's a bit dirty - it removes containers from the host, changes things and so on. But it works.</p><p>I did experiment with running these tests <em>in a container</em>, which has the benefit of giving you a clean host to start with, which you can throw away after each test.</p><p>I had to give up after a little while due to time constraints, but will probably revisit this process. The benefits of running these integration tests in a container is that we get a degree of isolation from the host.</p><p>If anyone is interested, my attempts so far are on this <a href=https://github.com/dwmkerr/docker-dynamodb/pull/2>RFC Pull Request</a>. Feel free to jump in!</p></div><footer class="post-footer clearfix"><p class=post-tags><span>Tagged:</span>
<a href=/dwmkerr.com/tags/Docker/>Docker</a>,
<a href=/dwmkerr.com/tags/DynamoDB/>DynamoDB</a>,
<a href=/dwmkerr.com/tags/Unix/>Unix</a>,
<a href=/dwmkerr.com/tags/Bash/>Bash</a>,
<a href=/dwmkerr.com/tags/Devops/>Devops</a>,
<a href=/dwmkerr.com/tags/Shell/>Shell</a>,
<a href=/dwmkerr.com/tags/CodeProject/>CodeProject</a></p><div class=share><a class=icon-twitter href="https://twitter.com/share?text=Simple%20Continuous%20Integration%20for%20Docker%20Images&url=https%3a%2f%2fdwmkerr.github.io%2fdwmkerr.com%2fsimple-continuous-integration-for-docker-images%2f" onclick="window.open(this.href,'twitter-share','width=550,height=235');return false;"><i class="fa fa-twitter"></i><span class=hidden>Twitter</span></a>
<a class=icon-facebook href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fdwmkerr.github.io%2fdwmkerr.com%2fsimple-continuous-integration-for-docker-images%2f" onclick="window.open(this.href,'facebook-share','width=580,height=296');return false;"><i class="fa fa-facebook"></i><span class=hidden>Facebook</span></a></div></footer><div class=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"dmwkerr"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></div></div><footer class=footer><div class=container><div class=site-title-wrapper><h1 class=site-title><a title=dwmkerr.com href=https://dwmkerr.github.io/dwmkerr.com/>dwmkerr.com</a></h1><a class="button-square button-jump-top js-jump-top" href=#><i class="fa fa-angle-up"></i></a></div><p class=footer-copyright><span>&copy; 2019 / Powered by <a href=https://gohugo.io/>Hugo</a></span></p><p class=footer-copyright><span><a href=https://github.com/roryg/ghostwriter>Ghostwriter theme</a> By <a href=http://jollygoodthemes.com>JollyGoodThemes</a></span>
<span>/ <a href=https://github.com/jbub/ghostwriter>Ported</a> to Hugo By <a href=https://github.com/jbub>jbub</a></span></p></div></footer><script src=https://dwmkerr.github.io/dwmkerr.com/js/jquery-1.11.3.min.js></script><script src=https://dwmkerr.github.io/dwmkerr.com/js/jquery.fitvids.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://dwmkerr.github.io/dwmkerr.com/js/scripts.js></script></body></html>
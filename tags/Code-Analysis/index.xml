<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Analysis on dwmkerr.com</title><link>http://example.org/tags/Code-Analysis/</link><description>Recent content in Code Analysis on dwmkerr.com</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><copyright>Dave Kerr</copyright><lastBuildDate>Tue, 20 Sep 2011 13:55:00 +0000</lastBuildDate><atom:link href="http://example.org/tags/Code-Analysis/index.xml" rel="self" type="application/rss+xml"/><item><title>Visual Studio Code Analysis - Buffer Overruns</title><link>http://example.org/visual-studio-code-analysis-buffer-overruns/</link><pubDate>Tue, 20 Sep 2011 13:55:00 +0000</pubDate><guid>http://example.org/visual-studio-code-analysis-buffer-overruns/</guid><description>#include &amp;ldquo;stdafx.h&amp;rdquo;
int _tmain(int argc, _TCHAR* argv[]) { // Create two buffers, one small, one large. TCHAR storageSmall[13]; TCHAR storageLarge[128];
// Get a pointer to a string literal.
TCHAR* str = _T(&amp;quot;Here is a string that is too long.&amp;quot;);
// Now do something very dangerous.
::_tcscpy(storageLarge, str);
::_tcscpy(storageSmall, storageLarge);
return 0;
}// Defined in Header2.h static const int LENGTH2 = 128;
// Defined in Header3.h typedef TCHAR LineOne[LENGTH1];
// Defined in Header4.</description></item></channel></rss>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SysAdmin on dwmkerr.com</title><link>https://dwmkerr.com/tags/sysadmin/</link><description>Recent content in SysAdmin on dwmkerr.com</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><copyright>Copright &amp;copy; Dave Kerr</copyright><lastBuildDate>Tue, 25 Jun 2019 07:25:23 +0000</lastBuildDate><atom:link href="https://dwmkerr.com/tags/sysadmin/index.xml" rel="self" type="application/rss+xml"/><item><title>Effective Shell Part 7: The Subtleties of Shell Commands</title><link>https://dwmkerr.com/effective-shell-7-shell-commands/</link><pubDate>Tue, 25 Jun 2019 07:25:23 +0000</pubDate><guid>https://dwmkerr.com/effective-shell-7-shell-commands/</guid><description>&lt;p>In this chapter, we'll take a look at the various different types of shell commands that exist and how this can affect your work.&lt;/p>
&lt;p>By the end of this chapter, you might even be able to make sense of the horrifying and perfectly syntactically valid code below:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">which &lt;span style="color:#66d9ef">$(&lt;/span>where &lt;span style="color:#66d9ef">$(&lt;/span>what &lt;span style="color:#66d9ef">$(&lt;/span>whence &lt;span style="color:#66d9ef">$(&lt;/span>whereis who&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://www.dwmkerr.com/effective-shell-part-1-navigating-the-command-line/">Part 1: Navigating the Command Line&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dwmkerr.com/effective-shell-part-2-become-a-clipboard-gymnast/">Part 2: Become a Clipboard Gymnast&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dwmkerr.com/effective-shell-part-3-getting-hepl/">Part 3: Getting Help&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwmkerr.com/effective-shell-4-moving-around/">Part 4: Moving Around&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwmkerr.com/effective-shell-part-5-understanding-the-shell/">Part 5: Interlude - Understanding the Shell&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwmkerr.com/effective-shell-6-job-control/">Part 6: Everything You Don't Need to Know About Job Control&lt;/a>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://dwmkerr.com/effective-shell-7-shell-commands/">Part 7: The Subtleties of Shell Commands&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="what-are-commands">What Are Commands?&lt;/h2>
&lt;p>This is &lt;em>really&lt;/em> important to understand! A &lt;em>command&lt;/em> in a shell is something you execute. It might take parameters. Generally it'll have a form like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">command param1 param2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We've already seen many commands during this series:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">ls &lt;span style="color:#75715e"># Show the contents of the current directory&lt;/span>
cd ~ &lt;span style="color:#75715e"># Move to the user&amp;#39;s home&lt;/span>
cat file.txt &lt;span style="color:#75715e"># Output the contents of &amp;#39;file.txt&amp;#39; to stdout&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But to be an effective shell user, you must understand that not all commands are created equal. The differences between the types of commands will affect how you use them.&lt;/p>
&lt;p>There are four types of commands in most shells:&lt;/p>
&lt;ol>
&lt;li>Executables&lt;/li>
&lt;li>&amp;ldquo;Built-Ins&amp;rdquo; (which we'll just call &lt;em>builtins&lt;/em> from now on)&lt;/li>
&lt;li>Functions&lt;/li>
&lt;li>Aliases&lt;/li>
&lt;/ol>
&lt;p>Let's quickly dig in and see a bit more.&lt;/p>
&lt;h2 id="executables---programs">Executables - Programs&lt;/h2>
&lt;p>Executables are just files with the &amp;lsquo;executable&amp;rsquo; bit set&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>. If I execute the &lt;code>cat&lt;/code> command, the shell will search for an executable named &lt;code>cat&lt;/code> in my &lt;code>$PATH&lt;/code>. If it finds it, it will run the program.&lt;/p>
&lt;pre>&lt;code>$ cat file.txt
This is a simple text file
&lt;/code>&lt;/pre>&lt;p>What is &lt;code>$PATH&lt;/code>? &lt;code>$PATH&lt;/code> is the standard environment variable used to define &lt;em>where&lt;/em> the shell should search for programs. If we temporarily &lt;em>empty&lt;/em> this variable, the shell won't find the command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> cat file.txt
bash: cat: No such file or directory
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Normally your &lt;code>$PATH&lt;/code> variable will include the standard locations for Linux programs - folders such as &lt;code>/bin&lt;/code>, &lt;code>/sbin&lt;/code>, &lt;code>/usr/bin&lt;/code> and so on&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>If you were to print the variable, you'd see a bunch of paths (they are separated by colons; I've put them on separate lines for readability):&lt;/p>
&lt;pre>&lt;code>/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
&lt;/code>&lt;/pre>&lt;p>The shell will start with the &lt;em>earlier&lt;/em> locations and move to the later ones. This allows &lt;em>local&lt;/em> flavours of tools to be installed for users, which will take precedence over &lt;em>general&lt;/em> versions of tools.&lt;/p>
&lt;p>There will likely be other locations too - you might see Java folders, package manager folders and so on.&lt;/p>
&lt;h2 id="executables---scripts">Executables - Scripts&lt;/h2>
&lt;p>Imagine we create a text file called &lt;code>dog&lt;/code> in the local folder:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e">#!/bin/sh
&lt;/span>&lt;span style="color:#75715e">&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;🐶 woof 🐶&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we make the file &lt;em>executable&lt;/em>, by running &lt;code>chmod +x dog&lt;/code>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>, then we can run this just like any other program - as long as we tell the shell to look for programs in the current directory:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;.&amp;#34;&lt;/span> dog
🐶 woof 🐶
&lt;/code>&lt;/pre>&lt;/div>&lt;p>More common would be to run the program by giving a path:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ ./dog
🐶 woof 🐶
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Or just move it to a standard location that the shell already checks for programs:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ mv dog /usr/local/bin
$ dog
🐶 woof 🐶
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The point is that executables don't &lt;em>have&lt;/em> to be compiled program code. If a file starts with &lt;code>#!&lt;/code> (the &amp;lsquo;shebang&amp;rsquo;), then the system will try to run the contents of the file with the program specified in the shebang.&lt;/p>
&lt;p>We will look at shebangs in greater detail in a later chapter.&lt;/p>
&lt;h2 id="builtins">Builtins&lt;/h2>
&lt;p>OK, so we've seen executables. What about a command like this?&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">local V&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span> echo $V
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will not find the &lt;code>local&lt;/code> executable anywhere on your system. It is a &lt;em>builtin&lt;/em> - a special command built directly into the shell program.&lt;/p>
&lt;p>Builtins are often highly specific to your shell. They might be used for programming (&lt;code>local&lt;/code> for example is used to declare a locally scoped variable), or they might be for very shell-specific features.&lt;/p>
&lt;p>This is where we need to take note. As soon as you are running a builtin, you are potentially using a feature that is specific to &lt;em>your&lt;/em> shell, rather than a program that is shared across the system and can be run by &lt;em>any&lt;/em> shell.&lt;/p>
&lt;p>Trying to programmatically execute &lt;code>local&lt;/code> as a process will fail - there is no executable with that name; it is purely a shell construct.&lt;/p>
&lt;p>So how do we know if a command is a builtin? The preferred method is to use the &lt;code>type&lt;/code> command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ type local
local is a shell builtin
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>type&lt;/code> command (which is &lt;em>itself&lt;/em> a builtin!) can tell you the exact type of shell command.&lt;/p>
&lt;p>Interestingly, you might be using more builtins than you think. &lt;code>echo&lt;/code> is a program, but most of the time you are not executing it when you are in a shell:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ type -a echo
echo is a shell builtin
echo is /bin/echo
&lt;/code>&lt;/pre>&lt;/div>&lt;p>By using the &lt;code>-a&lt;/code> flag on &lt;code>type&lt;/code> to show &lt;em>all&lt;/em> commands that match the name, we see that &lt;code>echo&lt;/code> is actually both a builtin &lt;em>and&lt;/em> a program.&lt;/p>
&lt;p>Many simple programs have builtin versions. The shell can execute them much faster.&lt;/p>
&lt;p>Some commands are a builtin so that they can function in a sensible manner. The &lt;code>cd&lt;/code> command changes the current directory - if we executed it as a process, it would change only the directory for the &lt;code>cd&lt;/code> process itself, not the shell, making it much less useful.&lt;/p>
&lt;p>Builtins will vary from shell to shell, but many shells are &amp;lsquo;Bash-like&amp;rsquo; - meaning they will have a set very similar to the Bash builtins, which you can see here:&lt;/p>
&lt;p>&lt;a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html">https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html&lt;/a>&lt;/p>
&lt;p>As should be familiar from &lt;a href="https://www.dwmkerr.com/effective-shell-part-3-getting-hepl/">Part 3: Getting Help&lt;/a>, you can get help for builtins:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ man source &lt;span style="color:#75715e"># source is a builtin&lt;/span>
BUILTIN&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> BSD General Commands Manual BUILTIN&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>
NAME
builtin, !, %, &lt;span style="color:#75715e"># ...snip...&lt;/span>
SYNOPSIS
builtin &lt;span style="color:#f92672">[&lt;/span>-options&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>args ...&lt;span style="color:#f92672">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, the manual will &lt;em>not&lt;/em> show information on specific builtins, which is a pain. Your shell &lt;em>might&lt;/em> have an option to show more details - for example, in Bash you can use &lt;code>help&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ help source
source: source filename &lt;span style="color:#f92672">[&lt;/span>arguments&lt;span style="color:#f92672">]&lt;/span>
Read and execute commands from FILENAME and &lt;span style="color:#66d9ef">return&lt;/span>. The pathnames
in $PATH are used to find the directory containing FILENAME. If any
ARGUMENTS are supplied, they become the positional parameters when
FILENAME is executed.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But remember: &lt;code>help&lt;/code> is a builtin; you might not find it in all shells (you won't find it in &lt;code>zsh&lt;/code>, for example). This highlights again the challenges of builtins.&lt;/p>
&lt;h2 id="functions">Functions&lt;/h2>
&lt;p>You can define your own shell functions. We will see a lot more of this later, but let's show a quick example for now:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ restart-shell &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> exec -l &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$SHELL&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This snippet creates a function that restarts the shell (quite useful if you are messing with shell configuration files or think you might have irreversibly goofed up your current session).&lt;/p>
&lt;p>We can execute this function just like any command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ restart-shell
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And running &lt;code>type&lt;/code> will show us that this is a function:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ type restart-shell
restart-shell is a &lt;span style="color:#66d9ef">function&lt;/span>
restart-shell &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
exec -l $SHELL
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Functions are one of the most powerful shell constructs we will see; they are extremely useful for building sophisticated logic. We're going to see them in a lot more detail later, but for now it is enough to know that they exist, and can run logic, and are run as commands.&lt;/p>
&lt;h2 id="aliases">Aliases&lt;/h2>
&lt;p>An alias is just a shortcut. Type in a certain set of characters, and the shell will replace them with the value defined in the alias.&lt;/p>
&lt;p>Some common commands are actually already aliases - for example, in my &lt;code>zsh&lt;/code> shell, the &lt;code>ls&lt;/code> command is an alias:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% type -a ls
ls is an alias &lt;span style="color:#66d9ef">for&lt;/span> ls -G
ls is /bin/ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I make sure that when I use the &lt;code>ls&lt;/code> command, the shell always expands it to &lt;code>ls -G&lt;/code>, which colours the output.&lt;/p>
&lt;p>We can quickly define aliases to save on keystrokes. For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ alias k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;kubectl&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From this point on, I can use the &lt;code>k&lt;/code> alias as shorthand for the &lt;code>kubectl&lt;/code> command.&lt;/p>
&lt;p>Aliases are far less sophisticated than functions. Think of them as keystroke savers and nothing more, and you won't go far wrong. Aliases are not portable across shells and have certain behaviours which can make them problematic to work with, there will be an entire chapter dedicated to alisases coming up in the series.&lt;/p>
&lt;h2 id="so-what">So What?&lt;/h2>
&lt;p>So we now hopefully have a greater understanding of the variety of shell commands. Not all commands are executables, not all of the commands we &lt;em>think&lt;/em> are executables necessarily are, and some commands might be more sophisticated.&lt;/p>
&lt;p>As a shell user, the key things to remember are:&lt;/p>
&lt;ol>
&lt;li>Executables are &amp;lsquo;safe&amp;rsquo; - they are programs your system can use; your shell just calls out to them.&lt;/li>
&lt;li>Builtins are &lt;em>very&lt;/em> shell-specific and usually control the shell itself&lt;/li>
&lt;li>Functions are powerful ways to write logic but will normally be shell-specific.&lt;/li>
&lt;li>Aliases are conveniences for human operators, but only in the context of an interactive shell.&lt;/li>
&lt;/ol>
&lt;p>To find out how a command is implemented, just use the &lt;code>type -a&lt;/code> command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ type -a cat
cat is /bin/cat
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="more-than-you-need-to-know">More than You Need to Know&lt;/h2>
&lt;p>OK, for the masochistic few, you might be wondering about all of the other commands and utilities you may have seen that can tell you about programs and commands:&lt;/p>
&lt;ul>
&lt;li>&lt;code>what&lt;/code>&lt;/li>
&lt;li>&lt;code>whatis&lt;/code>&lt;/li>
&lt;li>&lt;code>which&lt;/code>&lt;/li>
&lt;li>&lt;code>whence&lt;/code>&lt;/li>
&lt;li>&lt;code>where&lt;/code>&lt;/li>
&lt;li>&lt;code>whereis&lt;/code>&lt;/li>
&lt;li>&lt;code>command&lt;/code>&lt;/li>
&lt;li>&lt;code>type&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>A &lt;em>lot&lt;/em> of these are legacy and should be avoided, but for completeness sake, we'll go through them.&lt;/p>
&lt;h3 id="what">&lt;code>what&lt;/code>&lt;/h3>
&lt;p>&lt;code>what&lt;/code> reads out special metadata embedded in a program, generally used to identify the version of source code it was built from:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ what /bin/ls
/bin/ls
Copyright &lt;span style="color:#f92672">(&lt;/span>c&lt;span style="color:#f92672">)&lt;/span> 1989, 1993, &lt;span style="color:#ae81ff">1994&lt;/span>
PROGRAM:ls PROJECT:file_cmds-272.220.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There should be almost no circumstance in which you need to use it in your day-to-day work, but you might come across it if you &lt;em>meant&lt;/em> to type &lt;code>whatis&lt;/code>.&lt;/p>
&lt;h3 id="whatis">&lt;code>whatis&lt;/code>&lt;/h3>
&lt;p>&lt;code>whatis&lt;/code> searches a local help database for text. This can be useful in tracking down manual pages:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ whatis bash
bash&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> - GNU Bourne-Again SHell
bashbug&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> - report a bug in bash
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But I can't imagine it will be a regularly used tool by most users.&lt;/p>
&lt;h3 id="which">&lt;code>which&lt;/code>&lt;/h3>
&lt;p>&lt;code>which&lt;/code> will search your &lt;code>$PATH&lt;/code> to see whether an executable can be found. With the &lt;code>-a&lt;/code> flag, it will show all results.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ which -a vi
/usr/local/bin/vi
/usr/bin/vi
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>which&lt;/code> originated in &lt;code>csh&lt;/code>. It remains on many systems for compatibility but in general should be avoided due to potentially odd behaviour&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>.&lt;/p>
&lt;h3 id="whence">&lt;code>whence&lt;/code>&lt;/h3>
&lt;p>&lt;code>whence&lt;/code> was added to the Korn shell. You are unlikely to use it unless you are on systems using &lt;code>ksh&lt;/code>. &lt;code>zsh&lt;/code> also has this command, but it should be avoided and considered non-standard.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% whence brew
/usr/local/bin/brew
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="where">&lt;code>where&lt;/code>&lt;/h3>
&lt;p>This is a shell builtin that can provide information on commands, similar to &lt;code>type&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% where ls
ls: aliased to ls -G
/bin/ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>However, &lt;code>type&lt;/code> should be preferred, as it is more standard.&lt;/p>
&lt;h3 id="whereis">&lt;code>whereis&lt;/code>&lt;/h3>
&lt;p>&lt;code>whereis&lt;/code> is available on some systems and generally operates the same as &lt;code>which&lt;/code>, searching paths for an executable:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% whereis ls
/bin/ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Again, &lt;code>type&lt;/code> should be preferred for compatability.&lt;/p>
&lt;h3 id="command">&lt;code>command&lt;/code>&lt;/h3>
&lt;p>&lt;code>command&lt;/code> is defined in the POSIX standard, so should be expected to be present on most modern systems. Without arguments, it simply executes a command. With the &lt;code>-v&lt;/code> argument, you get a fairly machine-readable or processable response; with the &lt;code>-V&lt;/code> argument, you get a more human readable response:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% command -v ls
alias ls&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -G&amp;#39;&lt;/span>
% command -V ls
ls is an alias &lt;span style="color:#66d9ef">for&lt;/span> ls -G
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>command&lt;/code> can be useful in scripts, as we will see in later chapters.&lt;/p>
&lt;h3 id="type">&lt;code>type&lt;/code>&lt;/h3>
&lt;p>&lt;code>type&lt;/code> is part of the Unix standard and will be present in most modern systems. As we've already seen, it will identify the type of command as well as the location for an executable:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% type -a ls
ls is an alias &lt;span style="color:#66d9ef">for&lt;/span> ls -G
ls is /bin/ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This command can also be used to only search for paths:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% type -p ls
ls is /bin/ls
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Summary&lt;/strong>&lt;/p>
&lt;p>In summary, avoid anything that starts with &amp;lsquo;&lt;code>w&lt;/code>&amp;rsquo;! These are legacy commands, generally needed only when working on older Unix machines. &lt;code>type&lt;/code> or &lt;code>command&lt;/code> should be used instead.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>Footnotes&lt;/strong>&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>We will cover permissions and modes in later chapters. &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>Why these names and locations? It's a long story. The best place to start if you are intersted is the &lt;a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Filesystem Hierarchy Standard&lt;/a>. &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;code>chmod&lt;/code> changes the mode of a file; &lt;code>+x&lt;/code> means &amp;lsquo;add the executable bit&amp;rsquo;. This tells the operating system the file can be executed. &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>&lt;a href="https://unix.stackexchange.com/questions/85249/why-not-use-which-what-to-use-then">Stack Exchange: Why not use “which”? What to use then?&lt;/a> &lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description><category>CodeProject</category></item><item><title>Effective Shell Part 6: Everything You Don't Need To Know About Job Control</title><link>https://dwmkerr.com/effective-shell-6-job-control/</link><pubDate>Mon, 10 Jun 2019 08:26:33 +0000</pubDate><guid>https://dwmkerr.com/effective-shell-6-job-control/</guid><description>&lt;p>&lt;em>Job control&lt;/em> is a feature of most shells, which is generally not particularly intuitive to work with. However, knowing the basics can help prevent you from getting yourself into a tangle, and can from time to time make certain tasks a little easier.&lt;/p>
&lt;p>In this chapter, we'll look at the main features of job control, why it can be a problematic, and some alternatives.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.dwmkerr.com/effective-shell-part-1-navigating-the-command-line/">Part 1: Navigating the Command Line&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dwmkerr.com/effective-shell-part-2-become-a-clipboard-gymnast/">Part 2: Become a Clipboard Gymnast&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dwmkerr.com/effective-shell-part-3-getting-hepl/">Part 3: Getting Help&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwmkerr.com/effective-shell-4-moving-around/">Part 4: Moving Around&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dwmkerr.com/effective-shell-part-5-understanding-the-shell/">Part 5: Interlude - Understanding the Shell&lt;/a>&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://dwmkerr.com/effective-shell-6-job-control/">Part 6: Everything You Don't Need to Know About Job Control&lt;/a>&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://dwmkerr.com/effective-shell-7-shell-commands/">Part 7: The Subtleties of Shell Commands&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-job-control">What Is Job Control?&lt;/h2>
&lt;p>Let's start with an example. I am building a simple web page. It has one &lt;code>index.html&lt;/code> file, one &lt;code>styles.css&lt;/code> file, and one &lt;code>code.js&lt;/code> file. The &lt;code>index.html&lt;/code> file looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">title&lt;/span>&amp;gt;My New Project&amp;lt;/&lt;span style="color:#f92672">title&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">link&lt;/span> &lt;span style="color:#a6e22e">rel&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;stylesheet&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text/css&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;styles.css&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;code.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">head&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&lt;span style="color:#75715e">&amp;lt;!--&lt;/span>&lt;span style="color:#75715e"> Snip... &lt;/span>&lt;span style="color:#75715e">--&amp;gt;&lt;/span>
&amp;lt;/&lt;span style="color:#f92672">body&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">html&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Opening the file in a browser doesn't quite work, as it won't load the code or the styles. We need a web server to serve styles and code.&lt;/p>
&lt;p>A super-useful one-liner to run a web server on any machine with Python installed is:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In fact, this is so useful that I normally &lt;em>alias&lt;/em> this command, so that I can just type &lt;code>serve&lt;/code>. We'll see aliases in a later chapter.&lt;/p>
&lt;p>For now, if we run this command (you can get &lt;a href="https://github.com/dwmkerr/effective-shell/tree/master/6-job-control/sample">the three sample files here&lt;/a> if you want to try this yourself), then we can open the webpage in a browser, with the styles and code loaded:&lt;/p>
&lt;p>&lt;img src="images/website-screenshot.png" alt="Screenshot: Website" width="600" />&lt;/p>
&lt;p>We can also see that the server has served the HTML, JavaScript, and CSS files:&lt;/p>
&lt;p>&lt;img src="images/server-screenshot.png" alt="Screenshot: Server" width="600" />&lt;/p>
&lt;p>All well and good so far.&lt;/p>
&lt;h2 id="the-problem">The Problem&lt;/h2>
&lt;p>Let's say we want to now continue using our shell, maybe to edit the website with a terminal editor like Vim or Emacs, or we want to zip up the site, or just run any shell command&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>We have a problem. The &lt;code>python&lt;/code> process is still running - it's serving the website. Our shell is essentially useless, until we stop the server. See what happens when I try to edit a file:&lt;/p>
&lt;p>&lt;img src="images/blocked-shell.gif" alt="Demo: Blocked Shell" width="600" />&lt;/p>
&lt;p>In the example above, I try to run &lt;code>vi&lt;/code>, but nothing is happening. Standard input is not being read by the server and not being interpreted by the shell.&lt;/p>
&lt;p>I have to kill the server by hitting &lt;code>Ctrl+C&lt;/code> (which sends a &lt;code>SIGINT&lt;/code>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> - we'll see more about signals later), clear my screen to get rid of all of the error messages, then start again.&lt;/p>
&lt;p>This is obviously not optimal. Let's look at some solutions.&lt;/p>
&lt;h2 id="solution-1-start-the-server-in-the-background">Solution 1: Start the Server in the Background&lt;/h2>
&lt;p>In most shells, you can run a command and instruct the shell to run it in the &lt;em>background&lt;/em>. To do this, you end the line with an ampersand. Here's how the example would look in this case:&lt;/p>
&lt;p>&lt;img src="images/start-in-background.gif" alt="Demo: Starting a Background Job" width="600" />&lt;/p>
&lt;p>By ending the command with an &lt;code>&amp;amp;&lt;/code> ampersand symbol, we instruct the shell to run the command as a &lt;em>background job&lt;/em>. This means that our shell is still functional. The shell has also notified us that this command is running as a background job with a specific &lt;em>job number&lt;/em>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span> &amp;amp;
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">19372&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In slightly obtuse language, the shell has informed us that it has started a job in the background, with job number &lt;code>1&lt;/code> and that this job is currently handling the process with ID &lt;code>19372&lt;/code>.&lt;/p>
&lt;p>The ampersand solution is a fairly common pattern used in day-to-day work.&lt;/p>
&lt;h2 id="solution-2-move-the-server-to-the-background">Solution 2: Move the Server to the Background&lt;/h2>
&lt;p>Let's say you forgot to start the command in the background. Most likely in this case you'd kill the server with &lt;code>Ctrl+C&lt;/code> and then start it again with the &lt;code>&amp;amp;&lt;/code> option. However, what if this was a large file download or a task you didn't want to abort?&lt;/p>
&lt;p>In the example below, we'll move the job to the background:&lt;/p>
&lt;p>&lt;img src="images/move-to-background.gif" alt="Demo: Moving a Job to the Background" width="600" />&lt;/p>
&lt;p>The process is currently in the foreground, so my shell is inactive. Hitting &lt;code>Ctrl+Z&lt;/code> sends a &amp;lsquo;suspend&amp;rsquo; signal to the process&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>, pausing it and moving it to the background.&lt;/p>
&lt;p>Let's dissect this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
Serving HTTP on 0.0.0.0 port &lt;span style="color:#ae81ff">3000&lt;/span> ...
127.0.0.1 - - &lt;span style="color:#f92672">[&lt;/span>03/Jun/2019 13:38:45&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#34;GET / HTTP/1.1&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span> -
^Z
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + &lt;span style="color:#ae81ff">21268&lt;/span> suspended python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The shell echos as I type, so we see &lt;code>^Z&lt;/code> (i.e., the &lt;code>Ctrl+Z&lt;/code> chord I entered). The shell responds by moving the process into a background job and suspending it.&lt;/p>
&lt;p>The key here is that it is &lt;em>suspended&lt;/em>. The process is paused. So the web server is no longer serving. If you are following with the sample, reload your browser. The webpage fails to load, as the server process is not able to respond to requests.&lt;/p>
&lt;p>To &lt;em>continue&lt;/em> the job, in the background, we use the &lt;code>bg&lt;/code> (&amp;lsquo;background&amp;rsquo;) command, with a &lt;em>job identifier&lt;/em> (which always starts with a &lt;code>%&lt;/code> symbol - we'll see why soon) to tell the shell to continue the job:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% bg %1
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + &lt;span style="color:#ae81ff">21268&lt;/span> continued python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The shell lets us know the job is being continued, and if we load the webpage again, the content is shown as expected.&lt;/p>
&lt;p>As a final check, we run the &lt;code>jobs&lt;/code> command to see what jobs the shell is running:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% jobs
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + running python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And there you have it - our server is running as a background job. This is exactly what we would see if we run &lt;code>jobs&lt;/code> after starting the server with an &lt;code>&amp;amp;&lt;/code> at the end. In fact, using an &lt;code>&amp;amp;&lt;/code> is perhaps an easier way to remember how to continue a suspended job:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% %1 &amp;amp;
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + &lt;span style="color:#ae81ff">21268&lt;/span> continued python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the same way ending a command with &lt;code>&amp;amp;&lt;/code> runs it in the background, ending a job identifier with &lt;code>&amp;amp;&lt;/code> &lt;em>continues&lt;/em> it in the background.&lt;/p>
&lt;p>There is at least one more way to move a job to the background&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>, but I have not yet found it useful in any scenarios, and it is overly complex to explain. See the footnote for details if you are interested.&lt;/p>
&lt;h2 id="moving-background-jobs-to-the-foreground">Moving Background Jobs to the Foreground&lt;/h2>
&lt;p>If you have a job in the background, you can bring it back to the foreground with the &lt;code>fg&lt;/code> (&amp;lsquo;foreground&amp;rsquo;) command. Let's show the jobs, with the &lt;code>jobs&lt;/code> command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% jobs
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + running python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here I have a background job running a server. Any one of the following commands will bring it back to the foreground:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">fg %1 &lt;span style="color:#75715e"># Explicitly bring Job 1 into the foreground&lt;/span>
%1 &lt;span style="color:#75715e"># ...or in shorthand, just enter the job id...&lt;/span>
fg &lt;span style="color:#75715e"># ...if not given an id, fg and bg assume the most recent job.&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the job is in the foreground, and you can interact with the process again however you like.&lt;/p>
&lt;h2 id="cleaning-up-jobs">Cleaning Up Jobs&lt;/h2>
&lt;p>You might realise you cannot continue what you are doing because an old job is &lt;em>still running&lt;/em>. Here's an example:&lt;/p>
&lt;p>&lt;img src="images/kill-job.gif" alt="Demo: Cleaning Up Jobs" width="600" />&lt;/p>
&lt;p>I tried to run my web server, but there was still one running as a background job. The server failed to start because the port is in use.&lt;/p>
&lt;p>To clean it up, I run the &lt;code>jobs&lt;/code> command to list the jobs:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% jobs
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + suspended python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There's my old web server. Note that even though it is suspended, it'll still be blocking the port it is serving on&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>. The process is paused, but it is still holding onto all of the resources it is using.&lt;/p>
&lt;p>Now that I know the job identifier (&lt;code>%1&lt;/code> in this case), I can kill the job:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">% kill %1
&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> + &lt;span style="color:#ae81ff">22843&lt;/span> terminated python -m SimpleHTTPServer &lt;span style="color:#ae81ff">3000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;em>This is why job identifiers start with a percentage sign!&lt;/em> The &lt;code>kill&lt;/code> command I have used is not a special job control command (like &lt;code>bg&lt;/code> or &lt;code>fg&lt;/code>). It is the normal &lt;code>kill&lt;/code> command, which terminates a process. But shells that support job control can normally use a job identifier in place of a &lt;em>process identifier&lt;/em>. So rather than working out what the process identifier is that I need to kill, I can just use the job identifier&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>.&lt;/p>
&lt;h2 id="why-you-shouldnt-use-jobs">Why You Shouldn't Use Jobs&lt;/h2>
&lt;p>Avoid jobs. They are not intuitive to interface with, and they suffer from some serious problems.&lt;/p>
&lt;p>The most obvious one is that all jobs write to the same output, meaning you can quickly get garbled output like this:&lt;/p>
&lt;p>&lt;img src="images/output.png" alt="Screenshot: Garbled Output" width="600" />&lt;/p>
&lt;p>This is what happens when I run a job, which just outputs text every second. It's in the background, but it's printing all over my commands. Even running the &lt;code>jobs&lt;/code> command to try and find the job to stop it is difficult.&lt;/p>
&lt;p>Input is even more complex. If a job is &lt;em>running&lt;/em> in the background, but requires input, it will be &lt;em>silently suspended&lt;/em>. This can cause confusion.&lt;/p>
&lt;p>Jobs &lt;em>can&lt;/em> be used in scripts but must be done so with caution and could easily confuse a consumer of the script if they leave background jobs hanging around, which cannot be easily cleaned up&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>.&lt;/p>
&lt;p>Handling errors and exit codes for jobs can be problematic, causing confusion, poor error handling, or overly complex code.&lt;/p>
&lt;h2 id="how-to-escape-jobs">How to Escape Jobs&lt;/h2>
&lt;p>If there are two things to take away, it would be this:&lt;/p>
&lt;blockquote>
&lt;p>If you have started running a command in the foreground, and you don't want to stop it and would rather move it to the background, hit &lt;code>Ctrl+Z&lt;/code>. Then Google &amp;ldquo;job control&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;p>And:&lt;/p>
&lt;blockquote>
&lt;p>If you think there is a job running in the background, and it is messing with your screen, type &lt;code>fg&lt;/code> to bring it to the front and kill it with &lt;code>Ctrl+C&lt;/code>. Repeat as needed!&lt;/p>
&lt;/blockquote>
&lt;p>In either case, if you need to do something more subtle, you can return to this reference. But the first command should allow you to get your shell back while you work out how to continue the job, and the second should kill a background job that is messing with your screen.&lt;/p>
&lt;h2 id="alternatives-to-jobs">Alternatives to Jobs&lt;/h2>
&lt;p>If you are using any kind of modern terminal such as iTerm, Terminal or the GNOME Terminal, just open a new tab or split! Much easier.&lt;/p>
&lt;p>The benefit to this is that each tab gets its own standard input and output, so there's no risk of overwriting. And of course you can hide/reveal/rearrange the tabs however you like.&lt;/p>
&lt;p>The traditional alternative to a job for an operator who simply wants more than one thing going on at once would be a &lt;em>terminal multiplexer&lt;/em>, such as &lt;code>screen&lt;/code> or &lt;code>tmux&lt;/code>:&lt;/p>
&lt;p>&lt;img src="images/terminal-multiplexer.gif" alt="terminal-multiplexer">&lt;/p>
&lt;p>Multiplexers work in a very similar way to a modern graphical terminal - they manage many shell instances. The benefits to a modern terminal, such as iTerm, is that you have a very intuitive GUI and lots of features.&lt;/p>
&lt;p>The benefits to a multiplexer are that you can run them over SSH sessions to manage complex operations on remote machines and that they run a client-server model, meaning many people can work with many multiplexed processes (and they can persist beyond sessions).&lt;/p>
&lt;p>My personal preference is both - I use a modern terminal &lt;em>and&lt;/em> run everything inside it in &lt;code>tmux&lt;/code>. We'll look at both of these options in later chapters.&lt;/p>
&lt;h2 id="quick-reference">Quick Reference&lt;/h2>
&lt;p>You might find that jobs are useful, or you might find that they are not. Either way, here's a quick reference of some common commands:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Command&lt;/th>
&lt;th>Usage&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>command &amp;amp;&lt;/code>&lt;/td>
&lt;td>Run the command as a background job.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>&amp;lt;Ctrl+Z&amp;gt;&lt;/code>&lt;/td>
&lt;td>Move the current process into a background job, suspended.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>jobs&lt;/code>&lt;/td>
&lt;td>List all jobs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>fg %1&lt;/code>&lt;/td>
&lt;td>Move background job number 1 into the foreground.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>bg %1&lt;/code>&lt;/td>
&lt;td>Continue background job number 1.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kill %1&lt;/code>&lt;/td>
&lt;td>Terminate job number 1.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>wait %1&lt;/code>&lt;/td>
&lt;td>Block until job number 1 exits.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>If you want to find out more about the gory details of jobs, the best place to start is the &lt;a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Job-Control">Bash Manual - Job Control Section&lt;/a>, or the &amp;lsquo;Job Control&amp;rsquo; section of your preferred shell's manual.&lt;/p>
&lt;p>I hope you found this useful, and, as always, please leave comments, questions or suggestions below!&lt;/p>
&lt;hr>
&lt;h2 id="footnotes">Footnotes&lt;/h2>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>If you are not a heavy shell user, this might seem unlikely. But if you do a lot of work in shells, such as sysadmin, devops, or do your coding from a terminal, this happens all the time! &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>Signals like &lt;code>SIGINT&lt;/code>, &lt;code>SIGKILL&lt;/code>, &lt;code>SIGTERM&lt;/code> and so on will be covered in a later chapter. &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>Technically, &lt;code>SIGTSTP&lt;/code> - which is &amp;lsquo;TTY stop&amp;rsquo;. If you have always wondered about the &amp;lsquo;TTY&amp;rsquo; acroynm, check the previous chatper, &lt;a href="https://dwmkerr.com/effective-shell-part-5-understanding-the-shell/">Interlude: Understanding the Shell&lt;/a>. &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>The alternative method is to use &lt;code>Ctrl+Y&lt;/code>, which will send a &lt;em>delayed interrupt&lt;/em>, which will continue to run the process until it tries to read from &lt;code>stdin&lt;/code>. At this point, the job is suspended and the control given to the shell. The operator can then use &lt;code>bg&lt;/code> or &lt;code>kill&lt;/code> or &lt;code>fg&lt;/code> to either move to the background, stop the process, or keep in the foreground as preferred. See: &lt;a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Job-Control">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Job-Control&lt;/a> &lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>Another super-useful snippet: &lt;code>lsof -i -P -n | grep 8000&lt;/code> to find any process that has a given port open. Another one for the aliases chapter! &lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>There are times this is needed. If a job runs &lt;em>many processes&lt;/em> - for example, by running a pipeline - the process identifier will change as the command moves from one stage of the pipeline to the next. The job identifier will remain constant. Remember, a job is a shell &lt;em>command&lt;/em>, so could run many processes. &lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7" role="doc-endnote">
&lt;p>To see how bad this can be, create a script that starts jobs, then run it. Then run the &lt;code>jobs&lt;/code> command to see what is running. The output might surprise you! &lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description><category>CodeProject</category></item></channel></rss>
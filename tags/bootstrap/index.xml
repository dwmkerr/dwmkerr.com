<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bootstrap on dwmkerr.com</title><link>https://dwmkerr.com/tags/bootstrap/</link><description>Recent content in Bootstrap on dwmkerr.com</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><copyright>Copright &amp;copy; Dave Kerr</copyright><lastBuildDate>Mon, 16 Jun 2014 00:48:12 +0000</lastBuildDate><atom:link href="https://dwmkerr.com/tags/bootstrap/index.xml" rel="self" type="application/rss+xml"/><item><title>The Only AngularJS Modal Service You'll Ever Need</title><link>https://dwmkerr.com/the-only-angularjs-modal-service-youll-ever-need/</link><pubDate>Mon, 16 Jun 2014 00:48:12 +0000</pubDate><guid>https://dwmkerr.com/the-only-angularjs-modal-service-youll-ever-need/</guid><description>&lt;p>If you need modals in an AngularJS application, look no further. I'll show you how to use the &lt;a href="https://github.com/dwmkerr/angular-modal-service">Angular Modal Service&lt;/a> to add Bootstrap Modals or your own custom modals to your application.&lt;/p>
&lt;p>&lt;a href="http://jsfiddle.net/dwmkerr/8MVLJ/">See it in a fiddle&lt;/a> or check out &lt;a href="http://dwmkerr.github.io/angular-modal-service">a full set of samples online&lt;/a>.&lt;/p>
&lt;h4 id="contents">Contents&lt;/h4>
&lt;ol>
&lt;li>[Using the Angular Modal Service](#UsingTheAngular ModalService)&lt;/li>
&lt;li>&lt;a href="#AQuickExample">A Quick Example&lt;/a>&lt;/li>
&lt;li>&lt;a href="#DesignGoals">Design Goals&lt;/a>&lt;/li>
&lt;li>&lt;a href="#HowItWorks">How It Works&lt;/a>&lt;/li>
&lt;li>&lt;a href="#WrappingUp">Wrapping Up&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="using-the-angular-modal-service">Using the Angular Modal Service&lt;/h2>
&lt;p>Here's how you can use the Angular Modal Service to add a bootstrap modal to your application.&lt;/p>
&lt;h4 id="step-1-install-with-bower">Step 1: Install with Bower&lt;/h4>
&lt;p>Install the service with bower:&lt;/p>
&lt;pre>&lt;code>bower install angular-modal-service --save
&lt;/code>&lt;/pre>&lt;p>If you don't use bower, just get the source directly from the &lt;a href="https://github.com/dwmkerr/angular-modal-service/tree/master/dst">&lt;code>dst&lt;/code>&lt;/a> folder of the repo.&lt;/p>
&lt;h4 id="step-2-include-the-javascript">Step 2: Include the JavaScript&lt;/h4>
&lt;p>Include the JavaScript from the &lt;code>dst&lt;/code> folder or require it with require.js:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">script&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;bower_components\angular-modal-service\dst\angular-modal-service.min.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">script&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="step-3-add-it-as-a-dependency">Step 3: Add it as a dependency&lt;/h4>
&lt;p>Make sure the &lt;code>angularModalService&lt;/code> module is listed as a required module for your application:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">app&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">angular&lt;/span>.&lt;span style="color:#a6e22e">module&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;myApp&amp;#39;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;angularModalService&amp;#39;&lt;/span>]);
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="step-4-show-the-modal">Step 4: Show the Modal&lt;/h4>
&lt;p>Inject &lt;code>ModalService&lt;/code> into any controller, directive or service and call the &lt;code>showModal&lt;/code> function to show a modal:&lt;/p>
&lt;pre>&lt;code class="language-language" data-lang="language">app.controller('SampleController', function($scope, ModalService) {
ModalService.showModal({
templateUrl: &amp;quot;template.html&amp;quot;,
controller: &amp;quot;ModalController&amp;quot;
}).then(function(modal) {
//it's a bootstrap element, use 'modal' to show it
modal.element.modal();
modal.close.then(function(result) {
console.log(result);
});
});
);
&lt;/code>&lt;/pre>&lt;p>This code loads the HTML from &lt;code>template.html&lt;/code>, adds it to the DOM, creates a scope for it and creates an instance of a &lt;code>ModalController&lt;/code>.&lt;/p>
&lt;p>When this is done, the promise returned by the &lt;code>showModal&lt;/code> function resolves and you get a &lt;code>modal&lt;/code> object. This object contains the element created. If it's a Bootstrap modal just call &lt;code>modal&lt;/code> to show it, if it's a custom one you can show it by changing its CSS styles or using whatever APIs are provided. There's an example ofa custom modal in &lt;a href="http://dwmkerr.github.io/angular-modal-service/">the samples&lt;/a>.&lt;/p>
&lt;h4 id="step-5-close-the-modal">Step 5: Close the Modal&lt;/h4>
&lt;p>The controller that is created always has one extra parameter injected into it - a function called &lt;code>close&lt;/code>. Call this function to close the modal, anything you pass to it is passed to the caller as the &lt;code>result&lt;/code> object.&lt;/p>
&lt;pre>&lt;code class="language-language" data-lang="language">app.controller('ModalController', function($scope, close) {
// when you need to close the modal, call close
close(&amp;quot;Success!&amp;quot;);
});
&lt;/code>&lt;/pre>&lt;p>You can pass a number of milliseconds to wait before destroying the DOM element as an optional second parameter to &lt;code>close&lt;/code> - this is useful if the closing of the modal is animated and you don't want it to disappear before the animation completes.&lt;/p>
&lt;h2 id="a-quick-example">A Quick Example&lt;/h2>
&lt;p>Here's a fiddle of the modal service in action:&lt;/p>
&lt;iframe width="100%" height="300" src="http://jsfiddle.net/dwmkerr/8MVLJ/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0">&lt;/iframe>
&lt;p>One thing to note in this examples is that the template is just declared in the DOM - this works fine because the service always checks the template cache before attempting to load it from the server.&lt;/p>
&lt;p>There are more examples at &lt;a href="http://dwmkerr.github.io/angular-modal-service/">dwmkerr.github.io/angular-modal-service&lt;/a>.&lt;/p>
&lt;h2 id="design-goals">Design Goals&lt;/h2>
&lt;p>There are some other services for handling modals out there, notably &lt;a href="https://github.com/Fundoo-Solutions/angularjs-modal-service">Fundoo's Modal Service&lt;/a> and a few others. However, the design goals for my service were slightly different:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>No link to bootstrap&lt;/strong>. Bootstrap modals are complex with lots of options - if you want to use them then that's great, the service should work with them, but the complexity of the options for Bootstrap Modals should not increase the complexity of the service.&lt;/li>
&lt;li>&lt;strong>Extremely simple code&lt;/strong>. It's rare you'll write something that it will suit everyone's need. Rather than trying to please everyone, I want a service that is simple enough to understand so that it can be easily adapted by others.&lt;/li>
&lt;/ol>
&lt;p>So the core goal here is simplicity - if others can understand the code, then they can more effectively decide whether it's what they need, or build upon it.&lt;/p>
&lt;p>With these design goals in mind I built the angular modal service.&lt;/p>
&lt;h2 id="how-it-works">How It Works&lt;/h2>
&lt;p>I'm going to walk through a slightly simplified version of the code because it actually illustrates quite a few important concepts when working with AngularJS.&lt;/p>
&lt;p>One of the things that's useful to know is that this service creates a DOM element, builds a scope for it and instantiates a controller for it - what we're doing is &lt;em>very&lt;/em> similar to what AngularJS does behind the scenes when a directive is created.&lt;/p>
&lt;p>So let's dive in. We're going to define a service, so we need a module.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">module&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">angular&lt;/span>.&lt;span style="color:#a6e22e">module&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;angularModalService&amp;#39;&lt;/span>, []);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we have our module, we can define our service. I tend to write services in the form of classes, but this is a personal choice - it's just as valid to return a javascript object that contains functions and data.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">factory&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;ModalService&amp;#39;&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;$document&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;$compile&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;$controller&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;$http&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;$rootScope&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;$q&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;$timeout&amp;#39;&lt;/span>,
&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">$document&lt;/span>, &lt;span style="color:#a6e22e">$compile&lt;/span>, &lt;span style="color:#a6e22e">$controller&lt;/span>, &lt;span style="color:#a6e22e">$http&lt;/span>, &lt;span style="color:#a6e22e">$rootScope&lt;/span>, &lt;span style="color:#a6e22e">$q&lt;/span>, &lt;span style="color:#a6e22e">$timeout&lt;/span>) {
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I need a lot of injected components, we'll see why as we continue. I also use the explicit form of the function which takes the parameters as strings - this is the only safe way to write an injected function if you are minifying code.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js"> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">body&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$document&lt;/span>.&lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;body&amp;#39;&lt;/span>);
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ModalService&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">self&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>I use the &lt;code>$document&lt;/code> object to get the body element, which the modal will be appended to. I then create a class function and record &lt;code>this&lt;/code> as self, so that I can refer to the class instance in callbacks and so on.&lt;/p>
&lt;p>The next part of the code creates a function that will return the template, given either a raw template string or a template url. The reason we wrap this function like this is that the operation will either be synchronous or asynchronous, and I don't want the caller to care. So we use promises to wrap the logic.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">getTemplate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>, &lt;span style="color:#a6e22e">templateUrl&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">deferred&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$q&lt;/span>.&lt;span style="color:#a6e22e">defer&lt;/span>();
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>) {
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>);
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">templateUrl&lt;/span>) {
&lt;span style="color:#a6e22e">$http&lt;/span>({&lt;span style="color:#a6e22e">method&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;GET&amp;#39;&lt;/span>, &lt;span style="color:#a6e22e">url&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">templateUrl&lt;/span>, &lt;span style="color:#a6e22e">cache&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>})
.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>) {
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>);
})
.&lt;span style="color:#66d9ef">catch&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">error&lt;/span>) {
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">reject&lt;/span>(&lt;span style="color:#a6e22e">error&lt;/span>);
});
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">reject&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;No template or templateUrl has been specified.&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">promise&lt;/span>;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If any of this seems confusing, check out my article &lt;a href="http://www.dwmkerr.com/promises-in-angularjs-the-definitive-guide/">AngularJS Promises - The Definitive Guide&lt;/a>.&lt;/p>
&lt;p>Now to the main function.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">self&lt;/span>.&lt;span style="color:#a6e22e">showModal&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">options&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">deferred&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$q&lt;/span>.&lt;span style="color:#a6e22e">defer&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>showModal&lt;/code> function is going to have to do all sorts of async work - loading the template from the server and so on. So we are going to create a &lt;code>deferred&lt;/code> object and build a promise to return to the caller.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">controller&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">controller&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">controller&lt;/span>) {
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">reject&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;No controller has been specified.&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">promise&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we validate that a controller has been passed in as part of the options. Notice how just like in &lt;code>getTemplate&lt;/code> we use the &lt;code>reject&lt;/code> function to deal with error cases. Again, if error handling with promises seems unfamiliar, check out &lt;a href="http://www.dwmkerr.com/promises-in-angularjs-the-definitive-guide/">AngularJS Promises - The Definitive Guide&lt;/a>.&lt;/p>
&lt;p>Next we deal with the template.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">getTemplate&lt;/span>(&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">template&lt;/span>, &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">templateUrl&lt;/span>)
.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>) {
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We've used the &lt;code>getTemplate&lt;/code> function to get the template, sync or async it doesn't matter, our logic is the same.&lt;/p>
&lt;p>Now we can build a new scope for our modal.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">modalScope&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$rootScope&lt;/span>.&lt;span style="color:#a6e22e">$new&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We'll refer to this a lot later on. Now for some cleverness.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">closeDeferred&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$q&lt;/span>.&lt;span style="color:#a6e22e">defer&lt;/span>();
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">inputs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">$scope&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">modalScope&lt;/span>,
&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">delay&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">delay&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">delay&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#a6e22e">delay&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#a6e22e">$timeout&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;span style="color:#a6e22e">closeDeferred&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>);
}, &lt;span style="color:#a6e22e">delay&lt;/span>);
}
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This requires some explanation. First, we create a new &lt;code>deferred&lt;/code> object. This is going to be used to build a promise that is resolved when the modal closes.&lt;/p>
&lt;p>Now we build an &lt;code>input&lt;/code> object. This contains parameters we want to inject to the controller we're going to create. Any parameters the controller needs, such as &lt;code>$element&lt;/code>, &lt;code>$timeout&lt;/code> or whatever will be injected by angular. We're just going to make sure that the &lt;code>$scope&lt;/code> that is injected is the one we've just created, and that we also inject a function called &amp;lsquo;close&amp;rsquo;. This function simply resolves the promise we've created after a specified timeout.&lt;/p>
&lt;p>This means that any controller for a modal can take &lt;code>close&lt;/code> as a parameter, and we'll inject the function that resolves the promise. This promise is returned to the consumer so that they can take action when the modal closes. We also allow the controller to pass a variable to &lt;code>close&lt;/code> which is passed to the &lt;code>resolve&lt;/code> function as well.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">inputs&lt;/span>) {
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">inputName&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">inputs&lt;/span>) {
&lt;span style="color:#a6e22e">inputs&lt;/span>[&lt;span style="color:#a6e22e">inputName&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">inputs&lt;/span>[&lt;span style="color:#a6e22e">inputName&lt;/span>];
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Without the this code, the service is close to useless. What we do here is allow the caller to provide extra inputs to the controller. Imagine we have a list of items, maybe books for a library program, and when the use clicks on one we want to show a modal. The code that shows the modal needs to pass the selected book to the modal controller - by adding it to the &lt;code>inputs&lt;/code> object, the book can be injected into the controller. This allows to client to pass data &lt;strong>to&lt;/strong> the controller, with the parameter of the &lt;code>close&lt;/code> function used to return data &lt;strong>from&lt;/strong> the controller.&lt;/p>
&lt;p>Ready for some lower level Angular?&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">modalController&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$controller&lt;/span>(&lt;span style="color:#a6e22e">controller&lt;/span>, &lt;span style="color:#a6e22e">inputs&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">modalElementTemplate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">angular&lt;/span>.&lt;span style="color:#a6e22e">element&lt;/span>(&lt;span style="color:#a6e22e">template&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">linkFn&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">$compile&lt;/span>(&lt;span style="color:#a6e22e">modalElementTemplate&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">modalElement&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">linkFn&lt;/span>(&lt;span style="color:#a6e22e">modalScope&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Four innocuous lines that are actually quite complex.&lt;/p>
&lt;ol>
&lt;li>First, we create an instance of the controller with name &lt;code>controller&lt;/code>. Regardless of what AngularJS injects, we provide &lt;code>inputs&lt;/code> to be injected as well.&lt;/li>
&lt;li>Now we turn our raw template html into an AngularJS DOM element. AngularJS always works with jQuery or jQuery Lite elements, the &lt;code>angular.element&lt;/code> function takes raw HTML and turns it into a DOM element we can work with.&lt;/li>
&lt;li>Now we &lt;code>$compile&lt;/code> the element. This step goes over the DOM and expands all directives. We're turning raw DOM elements into elements that are expanded into directives, but we haven't yet linked this set of elements into a scope. This is the first step of the compile/link process.&lt;/li>
&lt;li>Finally, we can link the element. The &lt;code>$compile&lt;/code> function returns a link function which we call with a scope to link the DOM elements (fully expanded) to the specified scope.&lt;/li>
&lt;/ol>
&lt;p>This is very similar to AngularJS actually handles directives itself - creating a scope, loading a template, turning it into an element, compiling it and linking it.&lt;/p>
&lt;p>Why are compile and link separate steps? Think of it like this, the work that is done in compile is actually identical for each instance of a directive (or modal in our case). It's not related to an &lt;em>instance&lt;/em> of a directive or modal, it's just expanding the elements and directives. So this work can be done once only, saving a lot of time - then we just call link to create an &lt;em>instance&lt;/em> of our element, bound to a specific scope. So link logic is always per instance (you have a scope, you can &lt;code>$watch&lt;/code> and so on) whereas compile logic is per &lt;em>type&lt;/em> of directive.&lt;/p>
&lt;p>Based on this, we could in fact cache the results of the compile function on a per-template basis, as they can be reused and linked to a scope as necessary. However this is an optimisation that is currently left out.&lt;/p>
&lt;p>Now we can add the fully built element to the DOM and build our return object.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">body&lt;/span>.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#a6e22e">modalElement&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">modal&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;span style="color:#a6e22e">controller&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">modalController&lt;/span>,
&lt;span style="color:#a6e22e">scope&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">modalScope&lt;/span>,
&lt;span style="color:#a6e22e">element&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">modalElement&lt;/span>,
&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#a6e22e">closeDeferred&lt;/span>.&lt;span style="color:#a6e22e">promise&lt;/span>
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We return the four things the caller might need - the controller, scope, element and close promise. When the close promise is resolved, we also want to clean up:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">modal&lt;/span>.&lt;span style="color:#a6e22e">close&lt;/span>.&lt;span style="color:#a6e22e">then&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>) {
&lt;span style="color:#a6e22e">modalScope&lt;/span>.&lt;span style="color:#a6e22e">$destroy&lt;/span>();
&lt;span style="color:#a6e22e">modalElement&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>();
});
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">resolve&lt;/span>(&lt;span style="color:#a6e22e">modal&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So when &lt;code>close&lt;/code> is resolved, whatever happens we'll destroy the scope and clean up the DOM. Now we can resolve our promise with the &lt;code>modal&lt;/code> object we've built&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js"> .&lt;span style="color:#66d9ef">catch&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">error&lt;/span>) {
&lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">reject&lt;/span>(&lt;span style="color:#a6e22e">error&lt;/span>);
});
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">deferred&lt;/span>.&lt;span style="color:#a6e22e">promise&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;and we can pass errors that occured during &lt;code>getTemplate&lt;/code> to the caller and finally return the promise we've built.&lt;/p>
&lt;p>That's it! With this design we handle errors correctly, can pass data to and from the modal, clean up after ourselves and make sure that units of asynchronous work are handled with the standard pattern of promises.&lt;/p>
&lt;h2 id="wrapping-up">Wrapping Up&lt;/h2>
&lt;p>I hope you've found the service and some of the details of the code useful, as always comments are welcome, fork the code and have a play - let me know if you think of improvements or have questions,&lt;/p></description><category>CodeProject</category></item><item><title>XPath Studio - First Cut</title><link>https://dwmkerr.com/xpath-studio-first-cut/</link><pubDate>Sun, 09 Dec 2012 16:11:27 +0000</pubDate><guid>https://dwmkerr.com/xpath-studio-first-cut/</guid><description>&lt;p>I have just uploaded the first cut of my mini-project &amp;lsquo;XPath Studio&amp;rsquo;. This project is a small site that lets you choose a URL to a source webpage, and run any XPath query against it - showing the data that is returned from the query.&lt;/p>
&lt;p>At the moment this blog has an issue with images so I cannot upload screenshots, but in the next few days they'll be there. Until then, you can try out XPath Studio by visiting:&lt;/p>
&lt;p>&lt;a title="XPath Studio" href="http://www.xpathstudio.com" target="_blank">&lt;a href="http://www.xpathstudio.com">www.xpathstudio.com&lt;/a>&lt;/a>&lt;/p>
&lt;p>The project is ASP .NET MVC 4, with Razor. I've stripped out the bulk of the styling that's provided by default, and layed it out with &lt;a title="Twitter Bootstrap" href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap&lt;/a>.&lt;/p>
&lt;p>This is the first time that I've used Bootstrap and already have decided that it'll be my first choice for web applications, at least those in the proof of concept phase. The library is lightweight, easy to use, clean and simple.&lt;/p>
&lt;p>More updates on XPath Studio will come over the next few days, as I tweak the core functionality based on feedback.&lt;/p></description><category>CodeProject</category></item></channel></rss>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WPF on dwmkerr.com</title><link>https://dwmkerr.com/tags/wpf/</link><description>Recent content in WPF on dwmkerr.com</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><copyright>Copright &amp;copy; Dave Kerr</copyright><lastBuildDate>Wed, 12 Jun 2013 01:36:18 +0000</lastBuildDate><atom:link href="https://dwmkerr.com/tags/wpf/index.xml" rel="self" type="application/rss+xml"/><item><title>WPF and Visual Studio Addins</title><link>https://dwmkerr.com/wpf-and-visual-studio-addins/</link><pubDate>Wed, 12 Jun 2013 01:36:18 +0000</pubDate><guid>https://dwmkerr.com/wpf-and-visual-studio-addins/</guid><description>&lt;p>If at all possible nowadays, I write all my Windows UI code in WPF, it&amp;rsquo;s just quicker and easier than WinForms. Recently however, I came across a situation that you should just avoid.&lt;/p>
&lt;p>If you&amp;rsquo;re developing addins for multiple versions of Visual Studio - don&amp;rsquo;t use WPF for the Tools &amp;gt; Options windows. It&amp;rsquo;s just noit going to place nice out of the box. This is because there&amp;rsquo;s a lot of property page Win32 stuff going on in the host window that makes it hard to route messages properly - keyboard entry won&amp;rsquo;t work correctly, tab order will be messed up and more, it&amp;rsquo;s just not worth the pain.&lt;/p>
&lt;p>If you&amp;rsquo;re developing addins for later versions of Visual Studio, you can actually use the VSPackage functionality to build options pages with WPF with ease, just check &lt;a href="http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.uielementdialogpage.aspx" target="_blank">UIElementDialogPage&lt;/a>. In fact, read the article here:&lt;/p>
&lt;p>&lt;a title="Creating Option Pages by using MPF" href="http://msdn.microsoft.com/en-us/library/bb165039.aspx" target="_blank">Creating Options Pages by using MPF &lt;/a>&lt;/p>
&lt;p>Final thoughts on this - if you want the functionality above in VS2010, you can get it (as long as you use MPF) by checking this page:&lt;/p>
&lt;p>&lt;a href="http://social.msdn.microsoft.com/Forums/en-US/vsx/thread/6af9718e-8778-4233-875d-b38c03e9f4ba" target="_blank">Unable to access WPF User Control in Options Dialog&lt;/a>&lt;/p>
&lt;p>You&amp;rsquo;ll see that about halfway down, Ryan Moulden has posted some code from Microsoft for the UIElementDialogPage, you can use that you get the functionality in VS2010.&lt;/p>
&lt;p>Any other versions, or for a addin installed by an MSI, it&amp;rsquo;s probably best to stick with WinForms.&lt;/p>
&lt;p> &lt;/p></description><category>CodeProject</category></item><item><title>Introducing FireKeys</title><link>https://dwmkerr.com/introducing-firekeys/</link><pubDate>Mon, 11 Mar 2013 11:11:29 +0000</pubDate><guid>https://dwmkerr.com/introducing-firekeys/</guid><description>&lt;p>I don&amp;rsquo;t know when I learnt that Windows + E opened up Windows Explorer. It must have been a while ago. But it&amp;rsquo;s imprinted in my muscle memory, the number of times I hit that combo every day is probably quite high. But how many other hotkeys do I use? Asides from a few other functional ones, like Win + D, I don&amp;rsquo;t use hotkeys so much. And I got to thinking, I&amp;rsquo;d love to open Google Chrome with a hotkey just like I do with explorer.&lt;/p>
&lt;p>So I wrote FireKeys - a lightweight application that lets you assign hotkeys to actions. These actions could be opening program, a folder or a URL, but the underlying model is designed to be extensible.&lt;/p>
&lt;p>&lt;a href="http://www.dwmkerr.com/wp-content/uploads/2013/03/FireKeysMain.jpg">&lt;img src="images/FireKeysMain.jpg" alt="FireKeysMain" width="600" />&lt;/a>&lt;/p>
&lt;p>You can get the tool from the &lt;a title="FireKeys" href="http://www.dwmkerr.com/firekeys/">FireKeys&lt;/a> page. There&amp;rsquo;s an article on how it was developed on the CodeProject, &lt;a href="http://www.codeproject.com/Articles/559500/FireKeys-Open-Programs-Folders-or-URLs-with-Hot-Ke">FireKeys - Open Programs, Folders and URLs with Hot Keys&lt;/a>.&lt;/p></description><category>CodeProject</category></item><item><title>Funky WPF - Enumerations and the Combo Box</title><link>https://dwmkerr.com/funky-wpf-enumerations-and-the-combo-box/</link><pubDate>Wed, 18 Jan 2012 03:11:00 +0000</pubDate><guid>https://dwmkerr.com/funky-wpf-enumerations-and-the-combo-box/</guid><description>&lt;p class="MsoNormal">Binding a combo box to an enumeration in WPF is more work than it should be, creating an object data provider etc etc:&lt;/p>
&lt;pre class="brush: xml;">&amp;lt;Window.Resources&amp;gt;
&amp;lt;ObjectDataProvider MethodName="GetValues"
ObjectType="{x:Type sys:Enum}"
x:Key="CharacterEnumValues"&amp;gt;
&amp;lt;ObjectDataProvider.MethodParameters&amp;gt;
&amp;lt;x:Type TypeName="Character" /&amp;gt;
&amp;lt;/ObjectDataProvider.MethodParameters&amp;gt;
&amp;lt;/ObjectDataProvider&amp;gt;
&amp;lt;/Window.Resources&amp;gt;&lt;/pre>
&lt;p class="MsoNormal">Followed by&lt;/p>
&lt;pre class="brush: xml;">&amp;lt;ComboBox SelectedItem="{Binding Character}"&lt;br /> ItemsSource="{Binding &lt;br />Source={StaticResource CharacterValues}} "/&amp;gt;&lt;/pre>
&lt;p class="brush: xml;">What a pain! I have just added 'EnumerationComboBox' to my Apex library - so now you can do this:&lt;/p>
&lt;pre class="brush: xml;">&amp;lt;!-- The combo box, bound to an enumeration. --&amp;gt;
&amp;lt;apexControls:EnumerationComboBox &lt;br />SelectedEnumeration="{Binding Character}" /&amp;gt;&lt;/pre>
&lt;p class="MsoNormal">&lt;span lang="EN-US">No need for an ObjectDataProvider, an items source or anything &amp;ndash; and if you decorate enum&amp;rsquo;s with the &amp;lsquo;[Description]&amp;rsquo; attribute, it&amp;rsquo;ll use the description in the combo.&lt;/span>&lt;/p>
&lt;p class="MsoNormal">&lt;span lang="EN-US">There&amp;rsquo;s an article/download here for anyone who's interested:&lt;/span>&lt;/p>
&lt;p class="MsoNormal">&lt;a href="http://www.codeproject.com/KB/WPF/enumcombobox.aspx">http://www.codeproject.com/KB/WPF/enumcombobox.aspx&lt;/a>&lt;/p></description><category>CodeProject</category></item><item><title>MVVM Commanding</title><link>https://dwmkerr.com/mvvm-commanding/</link><pubDate>Sat, 29 Oct 2011 08:31:00 +0000</pubDate><guid>https://dwmkerr.com/mvvm-commanding/</guid><description>&lt;p>I have written an article that describes commanding in WPF, Silverlight and WP7 in detail. It is on the CodeProject at:&lt;/p>
&lt;p>&lt;a href="http://www.codeproject.com/KB/WPF/consistentmvvmcommands.aspx">http://www.codeproject.com/KB/WPF/consistentmvvmcommands.aspx&lt;/a>&lt;/p>
&lt;p>It uses the latest version of Apex (version 1.2) which will be released formally shortly. Enjoy!&lt;/p></description><category>CodeProject</category></item><item><title>MVVM: Asynchronous Commands</title><link>https://dwmkerr.com/mvvm-asynchronous-commands/</link><pubDate>Mon, 24 Oct 2011 03:51:00 +0000</pubDate><guid>https://dwmkerr.com/mvvm-asynchronous-commands/</guid><description>&lt;p>The latest cut of the Apex Code (&lt;a href="http://apex.codeplex.com/SourceControl/changeset/changes/6701">http://apex.codeplex.com/SourceControl/changeset/changes/6701&lt;/a>) contains a very cool new feature - Asynchronous Command Objects.&lt;/p>
&lt;p>An Asynchronous Command is a ViewModelCommand - the standard object used in Apex for commanding. However, what is different about this function is that it runs Asynchronously.&lt;/p>
&lt;p>One of the problems with running a view model command asynchronously is that generally the view model properties cannot be accessed - as they're created on a different dispatcher. This problem is resolved by using the 'ReportProgress' function. Here's an example:&lt;/p>
&lt;pre class="brush: c-sharp;">public class SomeViewModel : ViewModel
{
public SomeViewModel()
{
// Create the command.
asyncCommand = new AsynchronousCommand(DoAsyncCommand, true);
}
&lt;p>private void DoAsyncCommand()
{
for(int i = 0; i &amp;lt; 100; i++)
{
// Perform some long operation.
string message = DoSomeLongOperation();&lt;/p>
&lt;pre>&lt;code> // Add the message to the View Model - safely!
asyncCommand.ReportProgress(
() =&amp;amp;gt;
{
messages.Add(message);
}
);
}
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p>
&lt;p>private ObservableCollection&amp;lt;string&amp;gt; messages =
new ObservableCollection&amp;lt;string&amp;gt;();&lt;/p>
&lt;p>public ObservableCollection&amp;lt;string&amp;gt; Messages
{
get { return messages; }
}&lt;/p>
&lt;p>private AsynchronousCommand asyncCommand;&lt;/p>
&lt;p>public AsynchronousCommand AsyncCommand
{
get { return asyncCommand; }
}
}&lt;/pre>&lt;/p>
&lt;p class="brush: c-sharp;">In this basic mock-up we have a command called 'AsyncCommand' (which we could bind a button to for example) which invokes DoAsyncCommand. However, it invokes it Asynchronously. We can also update the ViewModel properties by using ReportProgress - meaning AsyncCommands can seamlessly provide live feedback while they're working - and we're keeping well locked in with the MVVM commanding model!&lt;/p>
&lt;p class="brush: c-sharp;">Expect a full article soon on the CodeProject, until then the source is at:&lt;/p>
&lt;p class="brush: c-sharp;">&lt;a href="http://apex.codeplex.com/SourceControl/changeset/changes/6701">http://apex.codeplex.com/SourceControl/changeset/changes/6701&lt;/a>&lt;/p></description><category>CodeProject</category></item><item><title>Drawing a DIB Section in WPF</title><link>https://dwmkerr.com/drawing-a-dib-section-in-wpf/</link><pubDate>Fri, 30 Sep 2011 05:09:00 +0000</pubDate><guid>https://dwmkerr.com/drawing-a-dib-section-in-wpf/</guid><description>&lt;p>One of the most exciting new features in the forthcoming SharpGL 2.0 (which was actually planned for 2.1 but has been moved to 2.0) is the facility to do OpenGL drawing in a WPF control. This isn't done via a WinFormsHost (which has unpleasant side-effects due to Airspace, see&amp;nbsp;&lt;a href="http://msdn.microsoft.com/en-us/library/aa970688(v=VS.100).aspx">http://msdn.microsoft.com/en-us/library/aa970688(v=VS.100).aspx&lt;/a>) but actually via an Image in a WPF UserControl.&lt;/p>
&lt;p>What does this mean? Well it means that when you use the SharpGL.WPF libraries OpenGLControl you get what is essentially a genuine WPF control - you can overlay other controls on top of it, with transparency and bitmap effects and do everything you'd normally be able to do with a WPF control.&lt;/p>
&lt;p>How this works is an interesting bit of code so here are the details.&lt;/p>
&lt;p>When using a WPF OpenGL control we render either using a DIBSectionRenderContextProvider, or a FBORenderContextProvider. Here's the difference:&lt;/p>
&lt;p>&lt;strong>DIBSectionRenderContextProvider&lt;/strong>&amp;nbsp;- Renders directly to a DIB Section. Supported with any version of OpenGL but never hardware accelerated.&lt;/p>
&lt;p>&lt;strong>FBORenderContextProvider&lt;/strong>&amp;nbsp;- Renders to a Framebuffer object, via the GL_EXT_framebuffer_object extension. This is fully hardware accelerated but only supported in OpenGL 1.3 and upwards. The resultant framebuffer is copied into a DIB section also.&lt;/p>
&lt;p>With either render context provider we end up with a DIB section that contains the frame - here's how we can render it:&lt;/p>
&lt;pre class="brush: c-sharp;">/// &amp;lt;summary&amp;gt;
/// Converts a &amp;lt;see cref="System.Drawing.Bitmap"/&amp;gt; into a WPF &amp;lt;see cref="BitmapSource"/&amp;gt;.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;remarks&amp;gt;Uses GDI to do the conversion. Hence the call to the marshalled DeleteObject.
/// &amp;lt;/remarks&amp;gt;
/// &amp;lt;param name="source"&amp;gt;The source bitmap.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;A BitmapSource&amp;lt;/returns&amp;gt;
public static BitmapSource HBitmapToBitmapSource(IntPtr hBitmap)
{
BitmapSource bitSrc = null;
&lt;pre>&lt;code>try
{
bitSrc = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(
hBitmap,
IntPtr.Zero,
Int32Rect.Empty,
BitmapSizeOptions.FromEmptyOptions());
}
catch (Win32Exception)
{
bitSrc = null;
}
finally
{
Win32.DeleteObject(hBitmap);
}
return bitSrc;
&lt;/code>&lt;/pre>
&lt;p>}&lt;/pre>&lt;/p>
&lt;p>This function allows us to turn a handle to a DIB section into a BitmapSource. The OpenGLControl is essentially just an image, and with each frame we simply set the BitmapSource to the newly rendered DIBSection.&lt;/p>
&lt;p>The version of the code this post relates to is:&amp;nbsp;&lt;a href="http://sharpgl.codeplex.com/SourceControl/changeset/view/4805">http://sharpgl.codeplex.com/SourceControl/changeset/view/4805&lt;/a>&lt;/p>
&lt;p>The WPF example renders the Utah Teapot (&lt;a href="http://en.wikipedia.org/wiki/Utah_teapot">http://en.wikipedia.org/wiki/Utah_teapot&lt;/a>) directly in a WPF application. We're still pre-beta but grab the code if you want to try OpenGL in WPF.&lt;/p></description><category>CodeProject</category></item><item><title>Solitaire and Spider Solitaire on the CodeProject</title><link>https://dwmkerr.com/solitaire-and-spider-solitaire-on-the-codeproject/</link><pubDate>Mon, 12 Sep 2011 06:01:00 +0000</pubDate><guid>https://dwmkerr.com/solitaire-and-spider-solitaire-on-the-codeproject/</guid><description>&lt;p>I have uploaded a new article on the CodeProject, a step by step tutorial showing how to create Solitaire and Spider Solitaire for WPF with the help of Apex.&lt;/p>
&lt;p>The article is available at: &lt;a href="http://www.codeproject.com/KB/WPF/solitaire.aspx">http://www.codeproject.com/KB/WPF/solitaire.aspx&lt;/a>&lt;/p></description><category>CodeProject</category></item></channel></rss>
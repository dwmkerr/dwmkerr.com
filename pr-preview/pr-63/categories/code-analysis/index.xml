<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Analysis on dwmkerr.com</title><link>https://dwmkerr.github.io/dwmkerr.com/pr-preview/pr-63/categories/code-analysis/</link><description>Recent content in Code Analysis on dwmkerr.com</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><copyright>Copright &amp;copy; Dave Kerr</copyright><lastBuildDate>Tue, 20 Sep 2011 13:55:00 +0000</lastBuildDate><atom:link href="https://dwmkerr.github.io/dwmkerr.com/pr-preview/pr-63/categories/code-analysis/index.xml" rel="self" type="application/rss+xml"/><item><title>Visual Studio Code Analysis - Buffer Overruns</title><link>https://dwmkerr.github.io/dwmkerr.com/pr-preview/pr-63/visual-studio-code-analysis-buffer-overruns/</link><pubDate>Tue, 20 Sep 2011 13:55:00 +0000</pubDate><guid>https://dwmkerr.github.io/dwmkerr.com/pr-preview/pr-63/visual-studio-code-analysis-buffer-overruns/</guid><description>&lt;p&gt;Today I was looking through some fairly old source code in a large solution, large in this case is ~300 projects and about 1 million lines of code. Parts of the code base are very old - at some stage a decision was made to disable warning C4996. The problem I came across is reduced to its most simple form below:&lt;/p&gt;
&lt;pre class="brush: c-sharp;"&gt;// AnalysisExample.cpp : An example of how static analysis can help.
//
&lt;p&gt;#include &amp;ldquo;stdafx.h&amp;rdquo;&lt;/p&gt;
&lt;p&gt;int _tmain(int argc, _TCHAR* argv[])
{
// Create two buffers, one small, one large.
TCHAR storageSmall[13];
TCHAR storageLarge[128];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Get a pointer to a string literal.
TCHAR* str = _T(&amp;quot;Here is a string that is too long.&amp;quot;);
// Now do something very dangerous.
::_tcscpy(storageLarge, str);
::_tcscpy(storageSmall, storageLarge);
return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Now in a sensible world with this warning enabled, we would get the following when compiling:&lt;/p&gt;
&lt;pre&gt;analysisexample.cpp(14): warning C4996: 'wcscpy':
This function or variable may be unsafe. Consider using
wcscpy_s instead. To disable deprecation, use
_CRT_SECURE_NO_WARNINGS. See online help for details.&lt;/pre&gt;
&lt;pre&gt;analysisexample.cpp(15): warning C4996: 'wcscpy':
This function or variable may be unsafe. Consider using
wcscpy_s instead. To disable deprecation, use
_CRT_SECURE_NO_WARNINGS. See online help for details.&lt;/pre&gt;
&lt;p&gt;The warning is telling us that wcscpy (which is what _tcscpy translates to in a Unicode build) is unsafe, which indeed it is as it does no buffer checking. However, when you migrate a Visual Studio 2005 solution to 2008 or straight to 2010 then suddenly you'll get lots of warnings like this. If there are thousands of warnings and they're masking other more important ones then you can see why maybe you'd consider disabling them.&lt;/p&gt;
&lt;p&gt;Why is this a bug?&lt;/p&gt;
&lt;p&gt;In case you didn't see it, a string literal that is 34 characters long (68 bytes) is copied to a buffer 128 characters long. OK so far. Then we copy the 34 characters into a smaller 13 character buffer - this causes a buffer overrun on the stack. In reality what happens is variables used subsequently in the function get overwritten unexpectedly. Or don't. Generally the worst case is that nothing odd happens during testing, but then the code blows up on-site with the customer, typically on something business critical like a database server - something it's hard to debug on.&lt;/p&gt;
&lt;p&gt;Visual Studio's Code Analysis tool is a life-saver. If you haven't used it before, get used to running it on &lt;em&gt;all&lt;/em&gt;&amp;nbsp;of your projects. Here's what happens when we run it (Analyze &amp;gt; Run Code Analysis On Solution):&lt;/p&gt;
&lt;pre&gt;1&amp;gt;analysisexample.cpp(18): warning C6202:
Buffer overrun for 'storageSmall', which is possibly
stack allocated, in call to 'wcscpy': length '256'
exceeds buffer size '26'&lt;/pre&gt;
&lt;p&gt;Code analysis has shown us &lt;em&gt;exactly&lt;/em&gt;&amp;nbsp;the problem, even with the warning disabled.&lt;/p&gt;
&lt;p&gt;So why is this important? Imagine we have the following four lines spread across four files:&lt;/p&gt;
&lt;pre class="brush: c-sharp;"&gt;// Defined in Header1.h
static const int LENGTH1 = 13;
&lt;p&gt;// Defined in Header2.h
static const int LENGTH2 = 128;&lt;/p&gt;
&lt;p&gt;// Defined in Header3.h
typedef TCHAR LineOne[LENGTH1];&lt;/p&gt;
&lt;p&gt;// Defined in Header4.h
typedef TCHAR LineTwo[LENGTH2];&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Our code could now look like this:&lt;/p&gt;
&lt;pre class="brush: c-sharp;"&gt;// Create two buffers, one small, one large.
LineOne storageSmall;
LineTwo storageLarge;
&lt;p&gt;// Get a pointer to a string literal.
TCHAR* str = _T(&amp;ldquo;Here is a string that is too long.&amp;rdquo;);&lt;/p&gt;
&lt;p&gt;// Now do something very dangerous.
::_tcscpy(storageLarge, str);
::_tcscpy(storageSmall, storageLarge);&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;Suddenly things aren't looking quite so obviously wrong - now imagine the different lines that make up this bug are spread across more files - or even more projects. Static analysis takes only a few seconds to run, unfortunately it's only available in the more expensive versions of visual studio.&lt;/p&gt;
&lt;p&gt;An even better solution - don't run the risk, use &lt;strong&gt;_tcscpy_s&lt;/strong&gt;&amp;nbsp;rather than &lt;strong&gt;_tcscpy &lt;/strong&gt;- it checks the buffer length without even requiring a single extra parameter in the example above.&lt;/p&gt;</description><category>CodeProject</category></item></channel></rss>